# L4.8 Implementation Plan - Orthogonality Peeling

**Date**: 2025-11-14
**Goal**: Implement strict descent operation for Wâ‚€(A) spanning proof
**Status**: Started - L4.7 complete, Disk.lean:790 integrated, L4.8.1 skeleton added

## Progress Summary

### âœ… Completed
1. **L4.7 (Dual Forest Existence)** - COMPLETE with 0 sorries
2. **Disk.lean Integration** - Line 790 now uses `DualForest.exists_spanning_forest`
3. **L4.8 Section** - Added to `DualForest.lean` at line 633

### ğŸš§ In Progress
**L4.8.1** (`forest_has_leaf_component`) - Skeleton added at line 647

## L4.8 Lemma Structure

### L4.8.1: Forest Has Leaf Component âœï¸ STARTED
**Location**: `DualForest.lean:647-662`
**Signature**:
```lean
lemma forest_has_leaf_component (G : DiskGeometry V E)
    (F : SpanningForest G)
    (h_ne : Nonempty {f // f âˆˆ G.toRotationSystem.internalFaces}) :
    âˆƒ (comp : (dualGraph G).ConnectedComponent),
      âˆƒ (e_cut : E), e_cut âˆˆ F.tree_edges âˆ§ ...
```

**What it proves**: Every non-empty spanning forest has a "leaf" component - one that connects to the rest via exactly one cut edge.

**Proof Strategy**:
- Use Mathlib's `SimpleGraph.IsTree.exists_leaf` or similar
- A forest is acyclic â‡’ each connected component is a tree
- Trees with >1 vertex have leaves (degree-1 vertices)
- Map from dual graph vertex (face) to component leaf

**Estimated**: 15-20 lines

### L4.8.2: Leaf Cut Edge is Singleton ğŸ“ TODO
**What it proves**: The "cut edge" of a leaf component is unique.

**Signature** (planned):
```lean
lemma leaf_cut_edge_unique (G : DiskGeometry V E)
    (F : SpanningForest G) (comp : (dualGraph G).ConnectedComponent)
    (e_cut : E) (h_leaf : IsLeafComponent F comp e_cut) :
    âˆ€ e âˆˆ F.tree_edges, e â‰  e_cut â†’
      (connects_component_to_outside e comp) â†’ False
```

**Proof Strategy**:
- By definition of leaf: degree 1 component
- Any other tree edge either:
  - Connects two faces within the component (not a cut edge)
  - Connects two faces outside the component (not relevant)
- Therefore e_cut is unique

**Estimated**: 10-15 lines

### L4.8.3: Toggle Support on Leaf ğŸ“ TODO
**What it proves**: The boundary sum over a leaf component has support exactly {e_cut}.

**Signature** (planned):
```lean
lemma toggle_support_leaf (G : DiskGeometry V E)
    (F : SpanningForest G) (comp : (dualGraph G).ConnectedComponent)
    (e_cut : E) (h_leaf : IsLeafComponent F comp e_cut)
    (Î³ : Color) :
    supportâ‚ (âˆ‘ f in comp_faces, faceBoundaryChain Î³ f) Î³ = {e_cut}
```

**Proof Strategy**:
- Leaf component = set of faces Sâ‚€
- Boundary âˆ‚Sâ‚€ consists of edges: some interior, some boundary
- Interior edges in âˆ‚Sâ‚€ are the "cut edges"
- By L4.6 (even parity): interior edges touched odd times by âˆ‚f cancel out mod 2
- Only e_cut (touched once) survives in the XOR
- Uses `supportâ‚_symm_diff_singleton`

**Estimated**: 15-20 lines

### L4.8.4: Toggle Orthogonality & Closure ğŸ“ TODO
**What it proves**: Toggle vector is in Wâ‚€ and orthogonal to interior.

**Signature** (planned):
```lean
lemma toggle_ortho_closure (G : DiskGeometry V E)
    (F : SpanningForest G) (comp : (dualGraph G).ConnectedComponent)
    (x : Chain) (hx : x âˆˆ G.zeroBoundarySet)
    (Î³ : Color) :
    let toggle := âˆ‘ f in comp_faces, faceBoundaryChain Î³ f
    toggle + x âˆˆ G.zeroBoundarySet âˆ§
    supportâ‚ toggle Î³ âŠ† G.toRotationSystem.boundaryEdges âˆª {e_cut}
```

**Proof Strategy**:
- Use L4.3 (purification): face boundaries are in Wâ‚€
- Linear combination of Wâ‚€ elements stays in Wâ‚€
- Support is on boundary âˆª {e_cut} by L4.8.3
- Orthogonality to interior follows from boundary+cut structure

**Estimated**: 10-15 lines

### L4.8.5: Strict Descent ğŸ“ TODO
**What it proves**: If e_cut âˆˆ supp(x), then toggling reduces support strictly.

**Signature** (planned):
```lean
lemma leaf_descent_strict (G : DiskGeometry V E)
    (F : SpanningForest G) (x : Chain)
    (hx : x âˆˆ G.zeroBoundarySet)
    (h_supp : supportâ‚ x Î³ â‰  âˆ…)
    (comp : (dualGraph G).ConnectedComponent)
    (e_cut : E) (h_leaf : IsLeafComponent F comp e_cut)
    (he_cut : e_cut âˆˆ supportâ‚ x Î³) :
    let x' := x + âˆ‘ f in comp_faces, faceBoundaryChain Î³ f
    card (supportâ‚ x' Î³) < card (supportâ‚ x Î³)
```

**Proof Strategy**:
- Have: `supp(toggle) = {e_cut}` (L4.8.3)
- Have: `e_cut âˆˆ supp(x)` (assumption)
- XOR property: `supp(x + toggle) = supp(x) Î” supp(toggle)`
- Since `supp(toggle) = {e_cut} âŠ† supp(x)`:
  - `supp(x') = supp(x) \ {e_cut}`
  - `card(supp(x')) = card(supp(x)) - 1`
- Strict descent!

**Estimated**: 10-15 lines

### L4.8 Main: Orthogonality Peeling ğŸ“ TODO
**What it proves**: The full peeling operation - combines all lemmas.

**Signature** (planned):
```lean
theorem orthogonality_peeling (G : DiskGeometry V E)
    (F : SpanningForest G) (x : Chain)
    (hx : x âˆˆ G.zeroBoundarySet)
    (h_supp : supportâ‚ x Î³ â‰  âˆ…)
    (h_ne : Nonempty {f // f âˆˆ G.toRotationSystem.internalFaces}) :
    âˆƒ (comp_faces : Finset (Finset E)),
      let x' := x + âˆ‘ f in comp_faces, faceBoundaryChain Î³ f
      x' âˆˆ G.zeroBoundarySet âˆ§
      card (supportâ‚ x' Î³) < card (supportâ‚ x Î³)
```

**Proof Strategy**:
```lean
by
  -- Get leaf component and cut edge (L4.8.1)
  obtain âŸ¨comp, e_cut, h_cut, h_leafâŸ© := forest_has_leaf_component G F h_ne

  -- Define toggle over leaf faces
  let comp_faces := { f | (dualGraph G).connectedComponentMk f = comp }
  let toggle := âˆ‘ f in comp_faces, faceBoundaryChain Î³ f
  use comp_faces

  constructor
  Â· -- x' âˆˆ Wâ‚€ (L4.8.4)
    exact (toggle_ortho_closure G F comp x hx Î³).1

  Â· -- Strict descent
    by_cases he_cut : e_cut âˆˆ supportâ‚ x Î³
    Â· -- Case 1: e_cut in support â†’ direct descent (L4.8.5)
      exact leaf_descent_strict G F x hx h_supp comp e_cut h_leaf he_cut
    Â· -- Case 2: e_cut not in support â†’ recurse on another leaf
      sorry  -- Bridge to Disk.lean descent machinery
```

**Estimated**: 20-25 lines

## Total Estimate

| Lemma | Lines | Status |
|-------|-------|--------|
| L4.8.1 | 15-20 | âœï¸ Skeleton added |
| L4.8.2 | 10-15 | ğŸ“ TODO |
| L4.8.3 | 15-20 | ğŸ“ TODO |
| L4.8.4 | 10-15 | ğŸ“ TODO |
| L4.8.5 | 10-15 | ğŸ“ TODO |
| L4.8 Main | 20-25 | ğŸ“ TODO |
| **Total** | **80-110** | **~10% done** |

**Estimated Time**: 2-3 hours total
- ~30 minutes per lemma (6 lemmas)
- Plus integration time with Disk.lean

## Dependencies & Bridges

### From L4.7 (Complete âœ…)
- `exists_spanning_forest`: Provides the forest `F`
- `spanning_tree_per_component`: Component-level trees
- `NoDigons`: Edge uniqueness property

### To Disk.lean (Integration Needed)
- `supportâ‚_strict_descent_via_leaf_toggle` (Disk.lean:1153): Existing descent machinery
- `aggregated_toggle_strict_descent_at_prescribed_cut` (Disk.lean:1075): Cut edge descent
- Bridge L4.8.5 case 2 (e_cut âˆ‰ supp) to recursive peeling

### To Spanning.lean (For Theorem 4.10)
- L4.8 provides the strict descent operation
- Combined with purification (L4.3-L4.4): proves spanning
- Final assembly: `Wâ‚€ âŠ† span(face_boundaries)`

## Next Steps

### Immediate (This Session)
1. âœ… Integrate L4.7 into Disk.lean (DONE - line 790)
2. âœ… Add L4.8 section to DualForest.lean (DONE - line 633)
3. âœ… Add L4.8.1 skeleton (DONE - line 647)

### Next (Following Sessions)
4. Prove L4.8.1 using Mathlib forest leaf theorem
5. Add and prove L4.8.2-L4.8.5 incrementally
6. Assemble L4.8 main theorem
7. Bridge to Disk.lean descent at line 1153

### Final (Theorem 4.10)
8. Update Spanning.lean to use L4.8
9. Prove `disk_kempe_closure_spanning`
10. **Complete Section 4!** ğŸ‰

## Files Modified

- âœ… `FourColor/Geometry/Disk.lean` (line 6: added DualForest import, line 788-790: integrated L4.7)
- âœ… `FourColor/Geometry/DualForest.lean` (line 633: added L4.8 section, line 647: L4.8.1 skeleton)
- ğŸ“ `FourColor/Kempe/Spanning.lean` (TODO: integrate L4.8 for Theorem 4.10)

## Build Status

**Currently**: Background build running with `LAKE_JOBS=4`
**Expected**: Clean compile of L4.7 integration
**Next**: Test L4.8.1 skeleton compiles

---

**Status**: L4.7 COMPLETE & integrated âœ… | L4.8 structure added âœï¸ | Ready to prove L4.8.1!
