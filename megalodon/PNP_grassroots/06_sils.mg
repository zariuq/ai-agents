(* ========================================================================== *)
(* 06_sils.mg - Sign-Invariant Local Sketches (SILS)                         *)
(* ========================================================================== *)
(* Section 2.3: Short, polytime, sign-invariant feature extractors           *)
(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* PART 1: SILS Definition (Definition 2.7)                                  *)
(* -------------------------------------------------------------------------- *)

(* A SILS extractor maps a masked CNF to a short, sign-invariant summary *)

Definition SILS_extractor : (set -> set) -> set -> prop :=
  fun feat m =>
    (* (F1) Sign/permutation invariance *)
    SILS_invariant feat m /\
    (* (F2) Short output: r(m) = O(log m) *)
    SILS_short feat m /\
    (* (F3) Efficient computability: poly(m) time *)
    SILS_polytime feat m.

(* -------------------------------------------------------------------------- *)
(* PART 2: SILS Properties                                                   *)
(* -------------------------------------------------------------------------- *)

(* (F1) Sign/permutation invariance under H_m *)
(* For all (pi, sigma) in H_m: feat(F^h) = feat(F^{(pi,sigma)h}) *)
Definition SILS_invariant : (set -> set) -> set -> prop :=
  fun feat m =>
    forall F h pi sigma,
      is_bijection m m pi ->
      SignVector m sigma ->
      feat (masked_cnf h F) = feat (masked_cnf (mask_compose (pi, sigma) h) F).

(* (F2) Short output: length O(log m) *)
Definition SILS_short : (set -> set) -> set -> prop :=
  fun feat m =>
    exists c :e omega,
      forall F, strlen (feat F) <= mul c (log2 m).

(* SILS output length function r(m) *)
Definition sils_length : set -> set :=
  fun m => mul c_sils (log2 m).

Definition c_sils : set := 3.  (* Constant in O(log m) *)

(* (F3) Polytime computability *)
Definition SILS_polytime : (set -> set) -> set -> prop :=
  fun feat m =>
    exists c :e omega,
      (* feat(F) computable in time m^c *)
      True.

(* -------------------------------------------------------------------------- *)
(* PART 3: SILS Contract (Definition 2.8)                                    *)
(* -------------------------------------------------------------------------- *)

(* SILS contract: z(F^h) depends only on the sign-invariant isomorphism type *)
(* of the factor graph of F^h *)

Definition SILS_contract : (set -> set) -> set -> prop :=
  fun z m =>
    (* z is polytime, outputs <= c_z * log(m) bits *)
    (forall F, strlen (z F) <= mul c_z (log2 m)) /\
    (* z depends only on sign-invariant structure *)
    (* i.e., invariant under H_m = S_m â‹‰ (Z_2)^m *)
    SILS_invariant z m.

Definition c_z : set := 4.  (* Absolute constant for length bound *)

(* Features depending on literal signs are EXCLUDED *)
(* E.g., clause-parity by signs is not allowed *)
(* Degree/profile and small-radius neighborhood counts ignoring signs ARE allowed *)

(* -------------------------------------------------------------------------- *)
(* PART 4: Concrete SILS Instantiations (Remark 2.9)                         *)
(* -------------------------------------------------------------------------- *)

(* (a) Degree/profile sketches *)
(* Degree histogram of variable-clause incidence, ignoring literal signs *)
Definition degree_sketch : set -> set :=
  fun F =>
    (* Bucketed logarithmically, hashed to O(log m) bits *)
    0.  (* Placeholder *)

(* (b) Local pattern counts *)
(* Counts of rooted incidence neighborhoods of fixed radius rho *)
Definition pattern_count_sketch : set -> set -> set :=
  fun F rho =>
    (* Counts ignoring signs, coarsened and hashed to O(log m) bits *)
    0.  (* Placeholder *)

(* (c) Co-occurrence statistics (sign-agnostic) *)
(* Quantized metrics of variable co-occurrence ignoring signs *)
Definition cooccurrence_sketch : set -> set :=
  fun F =>
    (* E.g., mutual-information surrogates, mapped to O(log m) bits *)
    0.  (* Placeholder *)

(* All these choices are H_m-invariant, short, and polytime computable *)
Theorem concrete_sils_valid :
  forall m,
    SILS_extractor degree_sketch m /\
    (forall rho, SILS_extractor (fun F => pattern_count_sketch F rho) m) /\
    SILS_extractor cooccurrence_sketch m.
Admitted.

(* -------------------------------------------------------------------------- *)
(* PART 5: SILS-Generated Sigma-Algebra                                      *)
(* -------------------------------------------------------------------------- *)

(* Let I denote the sigma-algebra generated by the SILS coordinates z *)
Definition SILS_sigma_algebra : (set -> set) -> set :=
  fun z => {B | exists f, forall F, (F :e B) <-> f (z F) = 1}.

(* I is sign-invariant by construction *)
Theorem SILS_sigma_algebra_sign_invariant :
  forall z m,
    SILS_extractor z m ->
    is_sign_invariant (fun F => z F) m.
Admitted.

(* -------------------------------------------------------------------------- *)
(* PART 6: Per-Bit Local Inputs (Definition 3.10)                            *)
(* -------------------------------------------------------------------------- *)

(* For block Phi and bit index i, the per-bit local input is: *)
(* u_i(Phi) = (z(F^h), a_i = A*e_i, b) in {0,1}^{O(log m)} *)

Definition local_input : set -> set -> set -> set :=
  fun z Phi i =>
    let Fh := instance_cnf Phi in
    let A := instance_matrix Phi in
    let b := instance_rhs Phi in
    (z Fh, vv_labels A b i).

(* Length of local input is O(log m) *)
Theorem local_input_length :
  forall z m Phi i,
    SILS_extractor z m ->
    strlen (local_input z Phi i) <= mul 3 (sils_length m).
Admitted.

(* The local alphabet U has polynomial size |U| = m^{O(1)} *)
Definition local_alphabet_size : set -> set :=
  fun m => exp 2 (mul 3 (sils_length m)).

Theorem local_alphabet_poly_size :
  forall m,
    local_alphabet_size m <= exp m 4.
Admitted.

(* -------------------------------------------------------------------------- *)
(* PART 7: Interface Contract                                                 *)
(* -------------------------------------------------------------------------- *)

(* What Sections 3-7 rely on: *)
(*   (i) Sign/permutation invariance (F1) for neutrality proofs *)
(*   (ii) Shortness (F2) and computability (F3) for post-switch rules *)
(*   (iii) Independence across blocks from sampling, not from feat *)

(* When using sparsification over radius-r charts, optionally use (F4) *)
Definition SILS_stability : (set -> set) -> set -> prop :=
  fun feat m =>
    (* feat depends only on multiset of bounded-radius neighborhoods *)
    True.

(* -------------------------------------------------------------------------- *)
(* END OF 06_sils.mg                                                          *)
(* -------------------------------------------------------------------------- *)
