:: M5 Step 1: Indicator chains
:: Maps a set of edges to a chain (characteristic function)

environ
  vocabularies
    CHAINDOT, XBOOLE_0, SUBSET_1, ZFMISC_1, XBOOLEAN, MARGREL1,
    GLIB_000, GLIB_001, GLIB_002, TARSKI, FUNCT_1, FUNCT_2;
  notations
    TARSKI, XBOOLE_0, SUBSET_1, ZFMISC_1, XBOOLEAN, MARGREL1,
    GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2;
  constructors
    SUBSET_1, ZFMISC_1, XBOOLEAN, MARGREL1,
    GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2;
  registrations
    XBOOLEAN, MARGREL1,
    GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2;
  requirements BOOLE, SUBSET;
  theorems XBOOLE_0, FUNCT_1, FUNCT_2, MARGREL1;
  schemes FUNCT_2;

begin

reserve G for _Graph;
reserve S for Subset of the_Edges_of G;
reserve e for Element of the_Edges_of G;

:: ============================================================================
:: Indicator chain for a set of edges
:: ============================================================================

:: Color for "edge is in the set" - use [TRUE, TRUE]
definition
  func indicator_color -> Element of GF2_squared equals [TRUE, TRUE];
  coherence by ZFMISC_1:def 2;
end;

:: Indicator chain: maps edges in S to indicator_color, others to zero_color
definition
  let G be _Graph;
  let S be Subset of the_Edges_of G;
  func indicator_chain(S) -> Chain of G means
  for e being Element of the_Edges_of G holds
    (e in S implies it.e = indicator_color) &
    (not e in S implies it.e = zero_color);
  existence
  proof
    defpred P[object, object] means
      ($1 in S & $2 = indicator_color) or (not $1 in S & $2 = zero_color);

    A1: for e being Element of the_Edges_of G
        ex c being Element of GF2_squared st P[e, c]
    proof
      let e be Element of the_Edges_of G;
      per cases;
      suppose e in S;
        reconsider c = indicator_color as Element of GF2_squared;
        take c;
        thus thesis;
      end;
      suppose not e in S;
        reconsider c = zero_color as Element of GF2_squared;
        take c;
        thus thesis;
      end;
    end;

    consider f being Function of the_Edges_of G, GF2_squared such that
    A2: for e being Element of the_Edges_of G holds P[e, f.e]
      from FUNCT_2:sch 1(A1);

    take f;
    let e be Element of the_Edges_of G;
    P[e, f.e] by A2;
    hence e in S implies f.e = indicator_color;
    thus not e in S implies f.e = zero_color;
  end;
  uniqueness
  proof
    let f1, f2 be Chain of G;
    assume A1: for e being Element of the_Edges_of G holds
      (e in S implies f1.e = indicator_color) &
      (not e in S implies f1.e = zero_color);
    assume A2: for e being Element of the_Edges_of G holds
      (e in S implies f2.e = indicator_color) &
      (not e in S implies f2.e = zero_color);
    for e being Element of the_Edges_of G holds f1.e = f2.e
    proof
      let e be Element of the_Edges_of G;
      per cases;
      suppose e in S;
        then f1.e = indicator_color & f2.e = indicator_color by A1, A2;
        hence f1.e = f2.e;
      end;
      suppose not e in S;
        then f1.e = zero_color & f2.e = zero_color by A1, A2;
        hence f1.e = f2.e;
      end;
    end;
    hence f1 = f2 by FUNCT_2:113;
  end;
end;

:: ============================================================================
:: Basic properties
:: ============================================================================

theorem Th_indicator_of_mem:
  e in S implies (indicator_chain S).e = indicator_color
proof
  assume e in S;
  hence thesis;
end;

theorem Th_indicator_of_not_mem:
  not e in S implies (indicator_chain S).e = zero_color
proof
  assume not e in S;
  hence thesis;
end;

:: Indicator of empty set is zero chain
theorem Th_indicator_empty:
  indicator_chain({} the_Edges_of G) = zero_chain(G)
proof
  set I = indicator_chain({} the_Edges_of G);
  for e being Element of the_Edges_of G holds I.e = (zero_chain G).e
  proof
    let e be Element of the_Edges_of G;
    not e in {} by XBOOLE_0:def 1;
    then I.e = zero_color;
    (zero_chain G).e = zero_color by FUNCT_2:63;
    hence I.e = (zero_chain G).e;
  end;
  hence thesis by FUNCT_2:113;
end;
