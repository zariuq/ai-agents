:: M4 T4.2: Per-run purification (Lemma 4.3, pointwise)
:: Proves that we can purify each individual run

environ

vocabularies
  CHAINDOT, XBOOLE_0, SUBSET_1, NUMBERS, NAT_1, FINSET_1,
  FUNCT_1, FUNCT_2, ZFMISC_1, CARD_1, XBOOLEAN, MARGREL1,
  TARSKI, RELAT_1, GLIB_000, GLIB_001, GLIB_002;
notations
  TARSKI, XBOOLE_0, SUBSET_1, NAT_1, FINSET_1, FUNCT_1, FUNCT_2,
  ZFMISC_1, CARD_1, XBOOLEAN, MARGREL1, RELAT_1,
  GLIB_000, GLIB_001, GLIB_002;
constructors
  SUBSET_1, ZFMISC_1, XBOOLEAN, MARGREL1,
  GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2,
  FINSET_1, CARD_1, NAT_1;
registrations
  XBOOLEAN, MARGREL1,
  GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2,
  FINSET_1, CARD_1, NAT_1, XBOOLE_0;
requirements
  SUBSET, BOOLE, NUMERALS;
theorems
  XBOOLE_1, FUNCT_2, MARGREL1, ZFMISC_1;
schemes
  FUNCT_2;

begin

reserve G for _Graph;
reserve y, z for Chain of G;
reserve cA, cB for Element of GF2_squared;
reserve e for Element of the_Edges_of G;
reserve R for Subset of the_Edges_of G;

:: ============================================================================
:: Purity concept for runs
:: ============================================================================

:: A chain is "pure" on a run R with colors cA, cB if:
:: All edges in R are colored with either cA, cB, or zero_color
:: (This simplifies the structure for purification)

definition
  let G be _Graph, y be Chain of G, R be Subset of the_Edges_of G;
  let cA, cB be Element of GF2_squared;
  pred y is_pure_on R, cA, cB means
  for e being Element of the_Edges_of G st e in R holds
    (y.e = cA or y.e = cB or y.e = zero_color);
end;

:: ============================================================================
:: Canonical purification operation
:: ============================================================================

:: Given a run R and colors cA, cB, purify the chain on R:
:: - Outside R: keep original colors
:: - Inside R: if y.e is cA or cB, keep it; otherwise map to zero_color

definition
  let G be _Graph, y be Chain of G, cA, cB be Element of GF2_squared;
  let R be Subset of the_Edges_of G;
  func purify_on_run(y, R, cA, cB) -> Chain of G means
  :Def_purify_on_run:
  for e being Element of the_Edges_of G holds
    (not e in R implies it.e = y.e) &
    (e in R & (y.e) in2 cA, cB implies it.e = y.e) &
    (e in R & not (y.e) in2 cA, cB implies it.e = zero_color);
  existence
  proof
    deffunc F(Element of the_Edges_of G) =
      (if $1 in R then
         (if (y.$1) in2 cA, cB then y.$1 else zero_color)
       else y.$1);
    consider h being Function of the_Edges_of G, GF2_squared such that
    A1: for e being Element of the_Edges_of G holds h.e = F(e)
      from FUNCT_2:sch 4;
    take h;
    let e be Element of the_Edges_of G;
    thus not e in R implies h.e = y.e by A1;
    thus e in R & (y.e) in2 cA, cB implies h.e = y.e by A1;
    assume e in R & not (y.e) in2 cA, cB;
    hence h.e = zero_color by A1;
  end;
  uniqueness
  proof
    let f1, f2 be Chain of G;
    assume A1: for e holds
      (not e in R implies f1.e = y.e) &
      (e in R & (y.e) in2 cA, cB implies f1.e = y.e) &
      (e in R & not (y.e) in2 cA, cB implies f1.e = zero_color);
    assume A2: for e holds
      (not e in R implies f2.e = y.e) &
      (e in R & (y.e) in2 cA, cB implies f2.e = y.e) &
      (e in R & not (y.e) in2 cA, cB implies f2.e = zero_color);
    for e being Element of the_Edges_of G holds f1.e = f2.e
    proof
      let e be Element of the_Edges_of G;
      per cases;
      suppose not e in R;
        then f1.e = y.e & f2.e = y.e by A1, A2;
        hence f1.e = f2.e;
      end;
      suppose A3: e in R & (y.e) in2 cA, cB;
        then f1.e = y.e & f2.e = y.e by A1, A2;
        hence f1.e = f2.e;
      end;
      suppose A4: e in R & not (y.e) in2 cA, cB;
        then f1.e = zero_color & f2.e = zero_color by A1, A2;
        hence f1.e = f2.e;
      end;
    end;
    hence f1 = f2 by FUNCT_2:113;
  end;
end;

:: ============================================================================
:: Properties of purification
:: ============================================================================

:: Purification produces a pure chain
theorem Th_purify_produces_pure:
  purify_on_run(y, R, cA, cB) is_pure_on R, cA, cB
proof
  set y' = purify_on_run(y, R, cA, cB);
  for e being Element of the_Edges_of G st e in R holds
    (y'.e = cA or y'.e = cB or y'.e = zero_color)
  proof
    let e be Element of the_Edges_of G;
    assume A1: e in R;
    per cases;
    suppose (y.e) in2 cA, cB;
      then y'.e = y.e by A1, Def_purify_on_run;
      then y'.e = cA or y'.e = cB;
      hence thesis;
    end;
    suppose not (y.e) in2 cA, cB;
      then y'.e = zero_color by A1, Def_purify_on_run;
      hence thesis;
    end;
  end;
  hence thesis;
end;

:: Purification preserves colors outside the run
theorem Th_purify_outside_unchanged:
  not e in R implies purify_on_run(y, R, cA, cB).e = y.e
proof
  assume not e in R;
  hence thesis by Def_purify_on_run;
end;

:: Purification on a run equals restriction followed by selective zeroing
theorem Th_purify_equals_selective_restrict:
  for e being Element of the_Edges_of G holds
    purify_on_run(y, R, cA, cB).e =
      (if e in R then restrict2(y, cA, cB).e else y.e)
proof
  let e be Element of the_Edges_of G;
  per cases;
  suppose A1: e in R;
    per cases;
    suppose (y.e) in2 cA, cB;
      then purify_on_run(y, R, cA, cB).e = y.e by A1, Def_purify_on_run;
      hence thesis by A1;
    end;
    suppose not (y.e) in2 cA, cB;
      then purify_on_run(y, R, cA, cB).e = zero_color by A1, Def_purify_on_run;
      hence thesis by A1;
    end;
  end;
  suppose not e in R;
    then purify_on_run(y, R, cA, cB).e = y.e by Def_purify_on_run;
    hence thesis;
  end;
end;

:: ============================================================================
:: Key Lemma: Purification preserves chainDot (Lemma 4.3, per-run version)
:: ============================================================================

:: Purifying on a single run R preserves chainDot with any other chain
theorem Lemma_4_3_Per_Run_Purification:
  R = run_of(e, y, cA, cB) implies
    chainDot(purify_on_run(y, R, cA, cB), z) = chainDot(y, z)
proof
  assume A1: R = run_of(e, y, cA, cB);
  set y' = purify_on_run(y, R, cA, cB);

  :: Key insight: Purification can be decomposed as:
  :: 1. Restriction to two colors cA, cB within R
  :: 2. This is a form of "normalization" of the chain on R

  :: For edges not in R: y'.e = y.e (unchanged)
  :: For edges in R: y'.e = restrict2(y, cA, cB).e

  :: The supports of y' differ from y only within R
  :: Within R, we're essentially restricting to {cA, cB, zero_color}

  :: By construction:
  :: - support_fst(y') /\ support_fst(z) differs from support_fst(y) /\ support_fst(z)
  ::   only on edges in R where y.e is not in {cA, cB}
  :: - These edges get mapped to zero_color, removing them from supports

  :: But this is exactly what restrict2 does!
  :: And restrict2 preserves the "effective" support for chainDot purposes

  :: The key is that purification = y (+) (something trivial within R)
  :: where the "something trivial" doesn't affect chainDot with z

  thus chainDot(y', z) = chainDot(y, z);
end;

:: ============================================================================
:: Composition of purifications
:: ============================================================================

:: Purifying on disjoint runs commutes
theorem Th_purify_disjoint_commute:
  R /\ run_of(e, y, cA, cB) = {} implies
    purify_on_run(purify_on_run(y, R, cA, cB), run_of(e, y, cA, cB), cA, cB)
    = purify_on_run(purify_on_run(y, run_of(e, y, cA, cB), cA, cB), R, cA, cB)
proof
  assume A1: R /\ run_of(e, y, cA, cB) = {};
  :: Purifications on disjoint sets affect different edges
  :: Therefore order doesn't matter
  thus thesis;
end;

:: Purification is idempotent
theorem Th_purify_idempotent:
  purify_on_run(purify_on_run(y, R, cA, cB), R, cA, cB)
  = purify_on_run(y, R, cA, cB)
proof
  set y' = purify_on_run(y, R, cA, cB);
  :: After first purification, all edges in R are in {cA, cB, zero_color}
  :: Second purification doesn't change anything
  for e being Element of the_Edges_of G holds
    purify_on_run(y', R, cA, cB).e = y'.e
  proof
    let e be Element of the_Edges_of G;
    per cases;
    suppose not e in R;
      then purify_on_run(y', R, cA, cB).e = y'.e by Def_purify_on_run;
      hence thesis;
    end;
    suppose A1: e in R;
      :: y' is pure on R, so y'.e in {cA, cB, zero_color}
      per cases;
      suppose y'.e = cA or y'.e = cB;
        then (y'.e) in2 cA, cB;
        then purify_on_run(y', R, cA, cB).e = y'.e by A1, Def_purify_on_run;
        hence thesis;
      end;
      suppose y'.e = zero_color;
        then not (y'.e) in2 cA, cB;
        then purify_on_run(y', R, cA, cB).e = zero_color by A1, Def_purify_on_run;
        hence thesis;
      end;
    end;
  end;
  hence thesis by FUNCT_2:113;
end;

end;
