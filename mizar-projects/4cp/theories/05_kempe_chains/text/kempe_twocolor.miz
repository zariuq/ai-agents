:: M4 T4.1b: Two-color restriction
:: Defines two-color edge sets and restriction operations for Kempe chains

environ

vocabularies
  CHAINDOT, XBOOLE_0, SUBSET_1, NUMBERS, NAT_1, FINSET_1,
  FUNCT_1, FUNCT_2, ZFMISC_1, CARD_1, XBOOLEAN, MARGREL1,
  TARSKI, RELAT_1, GLIB_000, GLIB_001, GLIB_002;
notations
  TARSKI, XBOOLE_0, SUBSET_1, NAT_1, FINSET_1, FUNCT_1, FUNCT_2,
  ZFMISC_1, CARD_1, XBOOLEAN, MARGREL1, RELAT_1,
  GLIB_000, GLIB_001, GLIB_002;
constructors
  SUBSET_1, ZFMISC_1, XBOOLEAN, MARGREL1,
  GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2,
  FINSET_1, CARD_1, NAT_1;
registrations
  XBOOLEAN, MARGREL1,
  GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2,
  FINSET_1, CARD_1, NAT_1, XBOOLE_0;
requirements
  SUBSET, BOOLE, NUMERALS;
theorems
  XBOOLE_1, FUNCT_2, MARGREL1, ZFMISC_1;
schemes
  FUNCT_2;

begin

reserve G for _Graph;
reserve y for Chain of G;
reserve cA, cB for Element of GF2_squared;
reserve e for Element of the_Edges_of G;

:: ============================================================================
:: Membership test for two selected colors
:: ============================================================================

definition
  let cA, cB, c be Element of GF2_squared;
  pred c in2 cA, cB means c = cA or c = cB;
end;

:: ============================================================================
:: The two-color edge set
:: ============================================================================

definition
  let G be _Graph, y be Chain of G, cA, cB be Element of GF2_squared;
  func two_color_edges(y, cA, cB) -> Subset of the_Edges_of G equals
    { e where e is Element of the_Edges_of G : (y.e) in2 cA, cB };
  coherence
  proof
    set S = { e where e is Element of the_Edges_of G : (y.e) in2 cA, cB };
    S c= the_Edges_of G
    proof
      let x be object;
      assume x in S;
      then ex e st x = e & (y.e) in2 cA, cB;
      hence x in the_Edges_of G;
    end;
    hence thesis;
  end;
end;

:: ============================================================================
:: Restriction to two colors (others mapped to zero_color)
:: ============================================================================

definition
  let G be _Graph, y be Chain of G, cA, cB be Element of GF2_squared;
  func restrict2(y, cA, cB) -> Chain of G means
  :Def_restrict2:
  for e being Element of the_Edges_of G holds
    ((y.e) in2 cA, cB implies it.e = y.e) &
    (not (y.e) in2 cA, cB implies it.e = zero_color);
  existence
  proof
    deffunc F(Element of the_Edges_of G) =
      (if (y.$1) in2 cA, cB then y.$1 else zero_color);
    consider h being Function of the_Edges_of G, GF2_squared such that
    A1: for e being Element of the_Edges_of G holds h.e = F(e)
      from FUNCT_2:sch 4;
    take h;
    let e be Element of the_Edges_of G;
    thus (y.e) in2 cA, cB implies h.e = y.e by A1;
    assume not (y.e) in2 cA, cB;
    hence h.e = zero_color by A1;
  end;
  uniqueness
  proof
    let f1, f2 be Chain of G;
    assume A1: for e holds
      ((y.e) in2 cA, cB implies f1.e = y.e) &
      (not (y.e) in2 cA, cB implies f1.e = zero_color);
    assume A2: for e holds
      ((y.e) in2 cA, cB implies f2.e = y.e) &
      (not (y.e) in2 cA, cB implies f2.e = zero_color);
    for e being Element of the_Edges_of G holds f1.e = f2.e
    proof
      let e be Element of the_Edges_of G;
      per cases;
      suppose (y.e) in2 cA, cB;
        then f1.e = y.e & f2.e = y.e by A1, A2;
        hence f1.e = f2.e;
      end;
      suppose not (y.e) in2 cA, cB;
        then f1.e = zero_color & f2.e = zero_color by A1, A2;
        hence f1.e = f2.e;
      end;
    end;
    hence f1 = f2 by FUNCT_2:113;
  end;
end;

:: ============================================================================
:: Basic properties of restriction
:: ============================================================================

:: Supports of restriction are subsets of original supports
theorem Th_support_fst_restrict2_subset:
  support_fst(restrict2(y, cA, cB)) c= support_fst(y)
proof
  let x be object;
  assume x in support_fst(restrict2(y, cA, cB));
  then consider e being Element of the_Edges_of G such that
  A1: x = e & (restrict2(y, cA, cB).e)`1 = TRUE;
  per cases;
  suppose (y.e) in2 cA, cB;
    then restrict2(y, cA, cB).e = y.e by Def_restrict2;
    hence thesis by A1;
  end;
  suppose not (y.e) in2 cA, cB;
    then restrict2(y, cA, cB).e = zero_color by Def_restrict2;
    :: zero_color`1 = FALSE, contradiction with A1
    hence thesis;
  end;
end;

theorem Th_support_snd_restrict2_subset:
  support_snd(restrict2(y, cA, cB)) c= support_snd(y)
proof
  let x be object;
  assume x in support_snd(restrict2(y, cA, cB));
  then consider e being Element of the_Edges_of G such that
  A1: x = e & (restrict2(y, cA, cB).e)`2 = TRUE;
  per cases;
  suppose (y.e) in2 cA, cB;
    then restrict2(y, cA, cB).e = y.e by Def_restrict2;
    hence thesis by A1;
  end;
  suppose not (y.e) in2 cA, cB;
    then restrict2(y, cA, cB).e = zero_color by Def_restrict2;
    :: zero_color`2 = FALSE, contradiction with A1
    hence thesis;
  end;
end;

:: Restriction is idempotent
theorem Th_restrict2_idem:
  restrict2(restrict2(y, cA, cB), cA, cB) = restrict2(y, cA, cB)
proof
  set r = restrict2(y, cA, cB);
  for e being Element of the_Edges_of G holds
    restrict2(r, cA, cB).e = r.e
  proof
    let e be Element of the_Edges_of G;
    per cases;
    suppose A1: (y.e) in2 cA, cB;
      then r.e = y.e by Def_restrict2;
      then (r.e) in2 cA, cB by A1;
      then restrict2(r, cA, cB).e = r.e by Def_restrict2;
      hence thesis;
    end;
    suppose A2: not (y.e) in2 cA, cB;
      then r.e = zero_color by Def_restrict2;
      then not (r.e) in2 cA, cB;
      then restrict2(r, cA, cB).e = zero_color by Def_restrict2;
      hence thesis by A2, Def_restrict2;
    end;
  end;
  hence thesis by FUNCT_2:113;
end;

:: Restriction of zero_chain is zero_chain
theorem Th_restrict2_zero:
  restrict2(zero_chain(G), cA, cB) = zero_chain(G)
proof
  for e being Element of the_Edges_of G holds
    restrict2(zero_chain(G), cA, cB).e = (zero_chain G).e
  proof
    let e be Element of the_Edges_of G;
    (zero_chain G).e = zero_color by FUNCT_2:63;
    then not ((zero_chain G).e) in2 cA, cB;
    then restrict2(zero_chain(G), cA, cB).e = zero_color by Def_restrict2;
    hence thesis by FUNCT_2:63;
  end;
  hence thesis by FUNCT_2:113;
end;

end;
