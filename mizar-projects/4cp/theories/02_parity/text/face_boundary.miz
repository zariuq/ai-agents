:: Face Boundary Infrastructure for 4CP
:: This module provides indicator chains and face boundary operations
:: over GF(2)² (the field with 2 elements, squared)
::
:: Based on Lean's Triangulation.lean:324-677
:: Ported from first draft, excluding placeholder sections

environ

 vocabularies NUMBERS, SUBSET_1, XBOOLE_0, TARSKI, RELAT_1, FUNCT_1,
      FINSET_1, NAT_1, ZFMISC_1, FUNCT_2, GLIB_000, GLIB_001,
      GLIB_002, MARGREL1, MCART_1, FUNCOP_1, CARD_1, ORDINAL1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, NAT_1, ORDINAL1,
      FINSET_1, RELAT_1, FUNCT_1, FUNCT_2, ZFMISC_1, GLIB_000, GLIB_001,
      GLIB_002, MARGREL1, MCART_1, FUNCOP_1;
 constructors NAT_1, FINSET_1, GLIB_000, GLIB_001, GLIB_002,
      MCART_1, FUNCOP_1, MARGREL1, ORDINAL1;
 registrations XBOOLE_0, SUBSET_1, FINSET_1, NAT_1, RELAT_1,
      GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2, ORDINAL1;
 requirements SUBSET, NUMERALS;
 definitions TARSKI, XBOOLE_0, FUNCT_1;
 schemes FUNCT_2;
 theorems XBOOLE_0, XBOOLE_1, TARSKI, FUNCT_1, FUNCT_2,
      GLIB_000, GLIB_001, GLIB_002, ZFMISC_1, MARGREL1,
      MCART_1, FUNCOP_1;

begin

:: ============================================================================
:: GF(2) AND GF(2)² INFRASTRUCTURE
:: ============================================================================

:: GF(2) is the field with 2 elements: {FALSE, TRUE}
definition
  func GF2 -> set equals BOOLEAN;
::>      *140,142,302
  correctness;
end;

registration
  cluster GF2 -> non empty finite;
::>         *302,140
  coherence;
end;

:: GF(2)² is the Cartesian product GF(2) × GF(2)
definition
  func GF2_squared -> set equals [: BOOLEAN, BOOLEAN :];
::>      *140,142,203
  correctness;
end;

registration
  cluster GF2_squared -> non empty finite;
::>         *140,203                     *223
  coherence;
end;

:: The zero element in GF(2)²
definition
  func zero_color -> Element of GF2_squared equals [FALSE, FALSE];
::>       *140,142,203
  correctness
  proof
    [FALSE, FALSE] in [: BOOLEAN, BOOLEAN :] by ZFMISC_1:87;
::>      *140   *140
    hence thesis;
  end;
end;

:: ============================================================================
:: CHAINS: FUNCTIONS FROM EDGES TO GF(2)²
:: ============================================================================

:: A chain assigns a GF(2)² element to each edge
definition
  let G be _Graph;
  mode Chain of G is Function of the_Edges_of G, GF2_squared;
::>        *303
  correctness;
end;

:: The zero chain assigns zero_color to every edge
definition
  let G be _Graph;
  func zero_chain(G) -> Chain of G equals
::>       *140,142,203
  (the_Edges_of G) --> zero_color;
  correctness;
end;

:: Addition in GF(2)²: component-wise XOR
definition
  let c1, c2 be Element of GF2_squared;
::>                          *140,203
  func c1 (+) c2 -> Element of GF2_squared equals
::>      *302
  ['c1`1 'xor' c2`1, c1`2 'xor' c2`2'];
  correctness
  proof
    c1`1 'xor' c2`1 in BOOLEAN & c1`2 'xor' c2`2 in BOOLEAN
::>    *165,203
      by MARGREL1:def 20;
    then ['c1`1 'xor' c2`1, c1`2 'xor' c2`2'] in [: BOOLEAN, BOOLEAN :]
::>       *203
      by ZFMISC_1:87;
    hence thesis;
  end;
end;

:: ============================================================================
:: INDICATOR CHAINS
:: ============================================================================

:: Corresponds to Lean's indicatorChain:
:: def indicatorChain {ι : Type*} [DecidableEq ι] (γ : Color) (S : Finset ι) :
::     ι → Color :=
::   fun e => if e ∈ S then γ else 0

:: An indicator chain assigns gamma to edges in F, zero_color elsewhere
definition
  let G be _Graph;
  let gamma be Element of GF2_squared;
::>                         *140,203
  let F be Subset of the_Edges_of G;
  func indicator_chain(gamma, F) -> Chain of G means
::>            *140,142,203
  :Def_indicator:
  for e being Element of the_Edges_of G holds
    (e in F implies it.e = gamma) &
    (not e in F implies it.e = zero_color);
  correctness
  proof
    existence
::>         *391
    proof
::>     *396
      defpred P[Element of the_Edges_of G, Element of GF2_squared] means
::>                                                     *140,203
        ($1 in F implies $2 = gamma) & (not $1 in F implies $2 = zero_color);

      A1: for e being Element of the_Edges_of G
        ex c being Element of GF2_squared st P[e, c]
::>                             *140,203
      proof
::>       *140
        let e be Element of the_Edges_of G;
        per cases;
        suppose e in F;
          then take gamma;
::>          *178 *391
          thus thesis;
        end;
        suppose not e in F;
          then take zero_color;
::>          *178 *391
          thus thesis;
        end;
      end;

      consider f being Function of the_Edges_of G, GF2_squared such that
::>                                                  *140,203
      A2: for e being Element of the_Edges_of G holds P[e, f.e]
        from FUNCT_2:sch 3(A1);
      take f;
      thus thesis by A2;
::>                   *144
    end;
    uniqueness
::>          *391
    proof
::>     *396
      let f1, f2 be Chain of G;
::>                        *306
      assume A3: for e being Element of the_Edges_of G holds
        (e in F implies f1.e = gamma) & (not e in F implies f1.e = zero_color);
::>                                                                   *140,203
      assume A4: for e being Element of the_Edges_of G holds
        (e in F implies f2.e = gamma) & (not e in F implies f2.e = zero_color);
::>                                                                   *140,203

      for e being Element of the_Edges_of G holds f1.e = f2.e
      proof
        let e be Element of the_Edges_of G;
        per cases;
        suppose A5: e in F;
          thus f1.e = gamma by A3, A5
                    .= f2.e by A4, A5;
        end;
        suppose A6: not e in F;
          thus f1.e = zero_color by A3, A6
::>                      *140,203
                    .= f2.e by A4, A6;
        end;
      end;
      hence f1 = f2 by FUNCT_2:113;
    end;
  end;
end;

:: Lean: lemma indicatorChain_of_mem
theorem Th_indicator_of_mem:
::>       *203
  for G being _Graph, gamma being Element of GF2_squared,
      F being Subset of the_Edges_of G,
      e being Element of the_Edges_of G
    st e in F holds indicator_chain(gamma, F).e = gamma
proof
  let G be _Graph, gamma be Element of GF2_squared,
::>                                      *140,203
      F be Subset of the_Edges_of G,
      e be Element of the_Edges_of G;
  assume e in F;
::>      *140 *140
  hence thesis by Def_indicator;
::>                  *203
end;

:: Lean: lemma indicatorChain_of_not_mem
theorem Th_indicator_of_not_mem:
::>       *203
  for G being _Graph, gamma being Element of GF2_squared,
      F being Subset of the_Edges_of G,
      e being Element of the_Edges_of G
    st not e in F holds indicator_chain(gamma, F).e = zero_color
proof
  let G be _Graph, gamma be Element of GF2_squared,
::>                                      *140,203
      F be Subset of the_Edges_of G,
      e be Element of the_Edges_of G;
  assume not e in F;
::>          *140 *140
  hence thesis by Def_indicator;
::>                  *203
end;

:: ============================================================================
:: FACE BOUNDARY CHAINS
:: ============================================================================

:: Corresponds to Lean's faceBoundaryChain:
:: def faceBoundaryChain (γ : Color) (f : Finset E) : E → Color :=
::   indicatorChain γ f

:: A face boundary chain is an indicator chain for a face
definition
  let G be _Graph;
  let gamma be Element of GF2_squared;
::>                         *140,203
  let f be Subset of the_Edges_of G;
  func face_boundary_chain(gamma, f) -> Chain of G equals
::>       *140,142,203
  indicator_chain(gamma, f);
  correctness;
end;

:: Lean: lemma faceBoundaryChain_add_self
:: Over GF(2)², a face boundary added to itself is the zero chain
theorem Th_face_boundary_add_self:
::>       *203
  for G being _Graph, gamma being Element of GF2_squared,
      f being Subset of the_Edges_of G holds
    face_boundary_chain(gamma, f) (+) face_boundary_chain(gamma, f)
      = zero_chain(G)
proof
  let G be _Graph, gamma be Element of GF2_squared,
::>                                      *140,203
      f be Subset of the_Edges_of G;
  set fbc = face_boundary_chain(gamma, f);
::>            *140,203

  for e being Element of the_Edges_of G holds
    (fbc (+) fbc).e = zero_chain(G).e
::>       *203
  proof
    let e be Element of the_Edges_of G;
    per cases;
    suppose A1: e in f;
::>                  *140
      thus (fbc (+) fbc).e = fbc.e (+) fbc.e
::>              *203
        .= gamma (+) gamma by A1, Th_indicator_of_mem
        .= ['gamma`1 'xor' gamma`1, gamma`2 'xor' gamma`2']
        .= [FALSE, FALSE] by MARGREL1:68
        .= zero_color
        .= zero_chain(G).e by FUNCOP_1:7;
    end;
    suppose A2: not e in f;
::>                      *140
      thus (fbc (+) fbc).e = fbc.e (+) fbc.e
::>              *203
        .= zero_color (+) zero_color by A2, Th_indicator_of_not_mem
        .= ['FALSE 'xor' FALSE, FALSE 'xor' FALSE']
        .= [FALSE, FALSE] by MARGREL1:67
        .= zero_color
        .= zero_chain(G).e by FUNCOP_1:7;
    end;
  end;
  hence thesis by FUNCT_2:113;
end;

:: ============================================================================
:: CHAIN XOR OPERATIONS
:: ============================================================================

:: Chain addition: pointwise XOR
definition
  let G be _Graph;
  let y1, y2 be Chain of G;
::>                    *306
  func y1 (+) y2 -> Chain of G means
::>      *302
  :Def_chain_xor:
  for e being Element of the_Edges_of G holds it.e = (y1.e) (+) (y2.e);
  correctness
  proof
    existence
::>         *391
    proof
::>     *396
      deffunc F(Element of the_Edges_of G) = (y1.$1) (+) (y2.$1);
::>                                                 *330
      consider f being Function of the_Edges_of G, GF2_squared such that
::>                                                  *140,203
      A1: for e being Element of the_Edges_of G holds f.e = F(e)
        from FUNCT_2:sch 4;
      take f;
      thus thesis by A1;
::>                   *144
    end;
    uniqueness
::>          *391
    proof
::>     *396
      let f1, f2 be Chain of G;
::>                        *306
      assume A2: for e being Element of the_Edges_of G
        holds f1.e = (y1.e) (+) (y2.e);
::>                        *330
      assume A3: for e being Element of the_Edges_of G
        holds f2.e = (y1.e) (+) (y2.e);
::>                        *330

      for e being Element of the_Edges_of G holds f1.e = f2.e
      proof
        let e be Element of the_Edges_of G;
        thus f1.e = (y1.e) (+) (y2.e) by A2
::>                        *395
                 .= f2.e by A3;
      end;
      hence f1 = f2 by FUNCT_2:113;
    end;
  end;
end;

:: XOR is commutative
theorem Th_chain_xor_comm:
::>       *203
  for G being _Graph, y1, y2 being Chain of G holds
    y1 (+) y2 = y2 (+) y1
proof
  let G be _Graph, y1, y2 be Chain of G;
::>                                 *306

  for e being Element of the_Edges_of G holds
    (y1 (+) y2).e = (y2 (+) y1).e
::>      *203
  proof
    let e be Element of the_Edges_of G;
    thus (y1 (+) y2).e = (y1.e) (+) (y2.e) by Def_chain_xor
::>           *203
      .= ['(y1.e)`1 'xor' (y2.e)`1, (y1.e)`2 'xor' (y2.e)`2']
      .= ['(y2.e)`1 'xor' (y1.e)`1, (y1.e)`2 'xor' (y2.e)`2'] by MARGREL1:70
      .= ['(y2.e)`1 'xor' (y1.e)`1, (y2.e)`2 'xor' (y1.e)`2'] by MARGREL1:70
      .= (y2.e) (+) (y1.e)
      .= (y2 (+) y1).e by Def_chain_xor;
  end;
  hence thesis by FUNCT_2:113;
end;

:: XOR is associative
theorem Th_chain_xor_assoc:
::>       *203
  for G being _Graph, y1, y2, y3 being Chain of G holds
    (y1 (+) y2) (+) y3 = y1 (+) (y2 (+) y3)
proof
  let G be _Graph, y1, y2, y3 be Chain of G;
::>                                     *306

  for e being Element of the_Edges_of G holds
    ((y1 (+) y2) (+) y3).e = (y1 (+) (y2 (+) y3)).e
::>       *203
  proof
    let e be Element of the_Edges_of G;
    thus ((y1 (+) y2) (+) y3).e
::>            *203
      = ((y1 (+) y2).e) (+) (y3.e) by Def_chain_xor
      .= ((y1.e) (+) (y2.e)) (+) (y3.e) by Def_chain_xor
      .= (y1.e) (+) ((y2.e) (+) (y3.e)) by MARGREL1:71
      .= (y1.e) (+) ((y2 (+) y3).e) by Def_chain_xor
      .= (y1 (+) (y2 (+) y3)).e by Def_chain_xor;
  end;
  hence thesis by FUNCT_2:113;
end;

:: Self-XOR is zero
theorem Th_chain_xor_self:
::>       *203
  for G being _Graph, y being Chain of G holds
    y (+) y = zero_chain(G)
proof
  let G be _Graph, y be Chain of G;
::>                            *306

  for e being Element of the_Edges_of G holds
    (y (+) y).e = zero_chain(G).e
::>     *203
  proof
    let e be Element of the_Edges_of G;
    thus (y (+) y).e = (y.e) (+) (y.e) by Def_chain_xor
::>          *203
      .= ['(y.e)`1 'xor' (y.e)`1, (y.e)`2 'xor' (y.e)`2']
      .= [FALSE, FALSE] by MARGREL1:68
      .= zero_color
      .= zero_chain(G).e by FUNCOP_1:7;
  end;
  hence thesis by FUNCT_2:113;
end;

:: ============================================================================
:: SUMMARY
:: ============================================================================

:: This file provides the foundation for face boundary operations:
:: - GF(2)² arithmetic (component-wise XOR)
:: - Chains: functions from edges to GF(2)²
:: - Indicator chains: characteristic functions as chains
:: - Face boundary chains: indicator chains for face edge sets
:: - Chain XOR: forms an abelian group with zero_chain as identity
::
:: Note: Face boundary span (finite XOR-sums) is omitted from this clean version.
:: It requires proper finite summation infrastructure not yet available.

end;
::>,216
::>
::> 140: Unknown variable
::> 142: Unknown locus
::> 144: Unknown label
::> 165: Unknown functor format
::> 178: Link assumes a straightforward justification
::> 203: Unknown token, maybe an illegal character used in an identifier
::> 216: Unexpected "end"
::> 223: Adjective cluster expected
::> 302: Functor symbol expected
::> 303: Mode symbol expected
::> 306: Attribute symbol expected
::> 330: Unexpected end of an item (perhaps ";" missing)
::> 391: Incorrect beginning of a text item
::> 395: Justification expected
::> 396: Formula expected
