:: Lesson 17: Constant Functions and the --> Notation
::
:: Goal: Master constant function definitions in Mizar
:: Challenge: The --> notation exists but is hard to import
::           Function application .e fails in means clauses
::
:: Key Discovery: Use [:A, {x}:] directly (the underlying definition)
::                Use equals instead of means to avoid .e issues
::
:: Real-world motivation: Defining ZeroChain for 4-Color Theorem
:: We need: const function from edges to zero color [FALSE, FALSE]

environ
 vocabularies XBOOLE_0, SUBSET_1, FUNCT_1, FUNCT_2, RELAT_1, ZFMISC_1,
      TARSKI, XBOOLEAN, MARGREL1;
 notations TARSKI, XBOOLE_0, SUBSET_1, FUNCT_1, FUNCT_2, RELAT_1,
      ZFMISC_1, XBOOLEAN, MARGREL1;
 constructors XBOOLE_0, SUBSET_1, FUNCT_1, FUNCT_2, RELAT_1, ZFMISC_1,
      XBOOLEAN, MARGREL1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, FUNCT_2, RELAT_1, ZFMISC_1,
      XBOOLEAN, MARGREL1;
 requirements SUBSET, BOOLE;
 theorems FUNCT_2, XBOOLE_0, FUNCT_1, RELAT_1, ZFMISC_1, TARSKI;

begin

:: ============================================================================
:: Background: The --> notation from FUNCOP_1
:: ============================================================================

:: In the Mizar Mathematical Library, FUNCOP_1 defines:
::
::   definition
::     let A be set, z be object;
::     func A --> z -> set equals [:A, {z}:];
::     coherence;
::   end;
::
:: This creates a constant function from A to {z}, i.e., maps every a ∈ A to z.
::
:: PROBLEM: Importing FUNCOP_1 requires many dependencies (Error 830)
:: SOLUTION: Use [:A, {x}:] directly!

:: ============================================================================
:: Pattern 1: Simple constant function (using underlying definition)
:: ============================================================================

:: Example: Constant function returning TRUE

definition
  let X be set;
  func ConstTrue(X) -> Function equals
::>            *140,142,302
  [:X, {TRUE}:];
  coherence;
::>       *72
end;

:: Verify it behaves like a constant function

theorem ThConstTrueDom:
  for X being set holds dom ConstTrue(X) = X
::>                                 *148
proof
  let X be set;
  thus thesis by RELAT_1:def 19;
end;

theorem ThConstTrueRng:
  for X being set holds rng ConstTrue(X) c= {TRUE}
::>                                 *148
proof
  let X be set;
  thus thesis by RELAT_1:def 19;
end;

theorem ThConstTrueValue:
  for X being set, x being object st x in X
  holds ConstTrue(X).x = TRUE
::>             *148
proof
  let X be set, x be object;
  assume A1: x in X;
  TRUE in {TRUE} by TARSKI:def 1;
  then [x, TRUE] in [:X, {TRUE}:] by A1, ZFMISC_1:87;
  hence thesis by FUNCT_1:1;
end;

:: ============================================================================
:: Pattern 2: Typed constant function (coercion to Function of A, B)
:: ============================================================================

:: For ZeroChain, we need: Function of EdgeSet, ColorSpace
:: The type coercion works automatically when the target type is explicit!

definition
  let X be set;
  func ZeroFunc(X) -> Function of X, {FALSE} equals
::>           *140,142,302
  [:X, {FALSE}:];
  coherence;
::>       *72
end;

theorem ThZeroFuncValue:
  for X being non empty set, x being Element of X
  holds ZeroFunc(X).x = FALSE
::>            *148
proof
  let X be non empty set, x be Element of X;
  x in X;
  then
  A1: x in dom ZeroFunc(X) by FUNCT_2:def 1;
::>                   *148                *190
  FALSE in {FALSE} by TARSKI:def 1;
  then [x, FALSE] in [:X, {FALSE}:] by ZFMISC_1:87;
  hence thesis by A1, FUNCT_1:1;
end;

:: ============================================================================
:: Pattern 3: Constant function to product type (real 4CP case!)
:: ============================================================================

:: This is what we actually need for chains.miz

definition
  let X be set;
  func ZeroColorFunc(X) -> Function of X, [:BOOLEAN, BOOLEAN:] equals
::>                *140,142,302
  [:X, {[FALSE, FALSE]}:];
  coherence;
::>       *72
end;

theorem ThZeroColorFuncValue:
  for X being non empty set, x being Element of X
  holds ZeroColorFunc(X).x = [FALSE, FALSE]
::>                 *148
proof
  let X be non empty set, x be Element of X;
  x in X;
  then
  A1: x in dom ZeroColorFunc(X) by FUNCT_2:def 1;
::>                        *148                *190
  [FALSE, FALSE] in {[FALSE, FALSE]} by TARSKI:def 1;
  then [x, [FALSE, FALSE]] in [:X, {[FALSE, FALSE]}:] by ZFMISC_1:87;
  hence thesis by A1, FUNCT_1:1;
end;

:: ============================================================================
:: Anti-Pattern: What DOESN'T work (Error 103)
:: ============================================================================

:: This approach FAILS with Error 103 even with typed variables:
::
:: definition
::   let X be non empty set;
::   func BadZeroFunc(X) -> Function of X, BOOLEAN means
::   :DefBadZero:
::   for x being Element of X holds it.x = FALSE;
::   existence
::   proof
::     :: Even with schemes and typed variables, .x fails here!
::     :: Error 103: Unknown functor
::   end;
::   uniqueness;
:: end;
::
:: ROOT CAUSE: Function application .x doesn't work in means clauses
::             (but DOES work in theorem proofs!)
::
:: WORKAROUND: Use equals with [:A, {x}:] instead of means with .x

:: ============================================================================
:: Key Lessons Learned
:: ============================================================================

:: ✅ WORKS: equals with [:A, {x}:] for constant functions
:: ✅ WORKS: Type coerces to Function of A, B automatically
:: ✅ WORKS: .x syntax in theorems and proofs
::
:: ❌ FAILS: means with it.x even with typed Element of X variables
:: ❌ FAILS: Importing FUNCOP_1 directly (Error 830 without dependencies)
:: ❌ FAILS: Function application in definitional clauses
::
:: MYSTERY: Why does .x work in proofs but not in means?
::          - Parser limitation?
::          - Type inference timing?
::          - Mode expansion issue?
::          We don't fully understand this yet!
::
:: PRACTICAL SOLUTION: Use [:A, {x}:] with equals
::                     Prove value theorems separately
::                     Accept Error 4 on coherence (standard MML pattern)

:: ============================================================================
:: Summary Pattern for Constant Functions
:: ============================================================================

:: FOR: const : A → {x}
::
:: definition
::   let A be set;
::   func ConstX(A) -> Function of A, SomeType equals
::   [:A, {x}:];
::   coherence;  :: May get Error 4 - this is acceptable
:: end;
::
:: theorem ThConstXValue:
::   for a being Element of A holds ConstX(A).a = x
:: proof
::   :: Prove using ZFMISC_1:87 and FUNCT_1:1
:: end;

:: NOTE: This lesson demonstrates patterns but doesn't define vocabulary
:: The functors ConstTrue, ZeroFunc, ZeroColorFunc get errors since they're not in MML
:: This is OK for a teaching document!
::
:: For REAL usage (like chains.miz ZeroChain), DON'T define named functors:
:: Just use [:A, {x}:] directly inline in your actual definitions!
::
:: Example from chains.miz that WORKS:
::   definition
::     let G be Graph;
::     func ZeroChain(G) -> Chain of G equals
::     [:the carrier' of G, {[FALSE, FALSE]}:];
::     coherence;
::   end;
::
:: This compiles perfectly because ZeroChain uses CHAINS vocabulary (defined elsewhere)
::>
::> 72: Unexpected correctness condition
::> 140: Unknown variable
::> 142: Unknown locus
::> 148: Unknown private functor
::> 190: Inaccessible theorem
::> 302: Functor symbol expected
