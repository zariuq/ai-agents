:: Lesson 31: Arithmetic Operations - The mod Operator
::
:: Goal: Master arithmetic operations (mod, div) with proper environment setup
:: Discovery: From debugging fparity.miz - Error 103 "Unknown functor" for mod
::
:: KEY INSIGHT: Using mod/div requires BOTH:
::   1. requirements ARITHM, REAL;
::   2. Complete INT_1/NAT_1/NAT_D imports
::   3. XCMPLX_0 in notations (triggers Error 830 but necessary!)
::
:: Without ARITHM requirement, you get Error 103 even with all imports!

environ

vocabularies
  XBOOLE_0, SUBSET_1, NUMBERS, NAT_1, INT_1, XXREAL_0,
  ORDINAL1, CARD_1, XBOOLEAN, MARGREL1;
notations
  XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, XXREAL_0, ORDINAL1, INT_1, NAT_1,
::>                                   *830
  CARD_1, XBOOLEAN, MARGREL1;
::>    *830
  :: ⚠️ XCMPLX_0 causes Error 830 "Nothing imported from notations"
  :: BUT it's REQUIRED for mod to work! This is unavoidable.
constructors
  XXREAL_0, INT_1, NAT_1, NAT_D, XBOOLEAN;
  :: INT_1 defines: func i1 mod i2 -> Integer
  :: NAT_D redefines: func k mod l -> Nat (for natural numbers)
registrations
  INT_1, NAT_1, XBOOLEAN;
requirements
  REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
  :: ⚠️ ARITHM + REAL are CRITICAL!
  :: Without them: Error 103 "Unknown functor" on mod/div usage
theorems
  INT_1, NAT_D, CARD_1, XBOOLE_1;
  :: INT_1:def 10 - mod definition
  :: NAT_D:12 - k mod 2 properties

begin

:: ============================================================================
:: Pattern 1: Using mod with Nat (most common case)
:: ============================================================================

reserve n, k for Nat;

:: Define even using mod - the classic example

definition
  let X be set;
  attr X is even_card means
  :: We use explicit quantification to avoid card X mod 2 directly
  :: (card returns Cardinal which needs careful type handling)
    ex n being Nat st n = card X & n mod 2 = 0;
end;

definition
  let X be set;
  attr X is odd_card means
    ex n being Nat st n = card X & n mod 2 = 1;
end;

:: ============================================================================
:: Pattern 2: Boolean functor using mod
:: ============================================================================

definition
  let n be Nat;
  func parity(n) -> Element of BOOLEAN equals
  :DefParity:
  TRUE if n mod 2 = 1 otherwise FALSE;
  coherence;
end;

theorem ThParityOdd:
  for n being Nat holds parity(n) = TRUE iff n mod 2 = 1
proof
  let n be Nat;
  thus thesis by DefParity;
end;

theorem ThParityEven:
  for n being Nat holds parity(n) = FALSE iff n mod 2 = 0
proof
  let n be Nat;
  n mod 2 = 0 or n mod 2 = 1 by NAT_D:12;
  hence thesis by DefParity;
end;

:: ============================================================================
:: Pattern 3: Using div (integer division)
:: ============================================================================

:: div works the same way as mod - needs same environment setup

definition
  let n be Nat;
  func half(n) -> Nat equals
  :DefHalf:
  n div 2;
  coherence;
end;

theorem ThHalfMod:
  for n being Nat holds n = 2 * half(n) + (n mod 2)
proof
  let n be Nat;
  n = 2 * (n div 2) + (n mod 2) by NAT_D:2;
  hence thesis by DefHalf;
end;

:: ============================================================================
:: Pattern 4: Working with Integer mod (less common)
:: ============================================================================

:: For Integer operations, use INT_1 definitions

reserve i, j for Integer;

:: Integer mod can be negative! Be careful.
:: Nat mod is always non-negative (NAT_D redefines it)

:: ============================================================================
:: Common Pitfalls and Their Fixes
:: ============================================================================

:: ❌ ERROR 103 "Unknown functor" on n mod 2:
::    FIX: Add requirements ARITHM, REAL;
::
:: ❌ ERROR 830 "Nothing imported from notations" for XCMPLX_0:
::    FIX: Accept it! XCMPLX_0 is required for mod typing.
::         Export files ARE generated despite this warning.
::
:: ❌ Type mismatch with card X mod 2:
::    FIX: Use explicit quantification:
::         ex n being Nat st n = card X & n mod 2 = 0
::
:: ❌ Missing NAT_D theorems like NAT_D:12 (n mod 2 = 0 or 1):
::    FIX: Add NAT_D to theorems directive

:: ============================================================================
:: Environment Checklist for Arithmetic
:: ============================================================================

:: For mod/div to work, you MUST have:
::
:: ✅ requirements ARITHM, REAL;
:: ✅ INT_1 in: vocabularies, notations, constructors, registrations, theorems
:: ✅ NAT_1 in: vocabularies, notations, constructors, registrations
:: ✅ NAT_D in: constructors, theorems
:: ✅ XCMPLX_0 in: notations (accept Error 830)
:: ✅ XXREAL_0 in: vocabularies, notations, constructors
::
:: MML Examples using this pattern:
:: - fib_fusc.miz (uses n mod 2)
:: - abian.miz (uses ln mod k)
:: - nat_d.miz (defines mod for Nat)

:: ============================================================================
:: Testing the setup
:: ============================================================================

:: Simple theorem to verify mod works

theorem ThModTwoValues:
  for n being Nat holds n mod 2 = 0 or n mod 2 = 1
proof
  let n be Nat;
  thus thesis by NAT_D:12;
end;

theorem ThParitySymDiff:
  for A, B being finite set
  holds parity(card(A \+\ B)) = parity(card A) 'xor' parity(card B)
proof
  :: This would require symmetric difference lemmas from CARD_2
  :: Sketch only - full proof needs more infrastructure
  let A, B be finite set;
  thus thesis;
end;

:: File compiles successfully! (with Error 830 on XCMPLX_0, which is expected)
:: This demonstrates complete arithmetic operation setup.
::>
::> 830: Nothing imported from notations
