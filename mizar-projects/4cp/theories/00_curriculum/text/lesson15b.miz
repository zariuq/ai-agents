:: Lesson 15B: Pair Operations - Existential Decomposition Pattern
::
:: Goal: Master the decomposition pattern for defining pair-valued operations
:: Contrast with: Lesson 15A (accessors) - use that for READING pairs
::                This lesson (decomposition) - use for DEFINING operations
::
:: WHEN TO USE DECOMPOSITION:
:: - Defining operations that return pairs (func ... means)
:: - Proving existence & uniqueness
:: - When you need structural theorems about pairs
::
:: This pattern is IDIOMATIC in MML and works robustly!

environ
 vocabularies LSN15B, XBOOLE_0, SUBSET_1, ZFMISC_1, MARGREL1, XBOOLEAN,
      NUMBERS, TARSKI, FINSET_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, ZFMISC_1, MARGREL1, XBOOLEAN,
      FINSET_1;
 constructors XBOOLE_0, SUBSET_1, ZFMISC_1, MARGREL1, XBOOLEAN, FINSET_1;
 registrations XBOOLE_0, SUBSET_1, ZFMISC_1, MARGREL1, XBOOLEAN, FINSET_1;
 requirements SUBSET, BOOLE;
 definitions XBOOLE_0;
 theorems ZFMISC_1, XBOOLE_0, MARGREL1, XBOOLEAN;

begin

:: ============================================================================
:: The BoolPair type
:: ============================================================================

definition
  func BoolPair -> set equals
  [: BOOLEAN, BOOLEAN :];
  coherence;
end;

registration
  cluster BoolPair -> non empty;
  coherence;
end;

:: ============================================================================
:: THE WORKING PATTERN: Decomposition Theorem
:: ============================================================================

theorem ThDecompose:
  for p being Element of BoolPair
  ex b1, b2 being Element of BOOLEAN st p = [b1, b2]
proof
  let p be Element of BoolPair;
  p in [: BOOLEAN, BOOLEAN :];
  then consider b1, b2 being object such that
  A1: b1 in BOOLEAN & b2 in BOOLEAN & p = [b1, b2] by ZFMISC_1:84;
  reconsider b1, b2 as Element of BOOLEAN by A1;
  take b1, b2;
  thus thesis by A1;
end;

:: ============================================================================
:: Defining operations: XOR on pairs
:: ============================================================================

definition
  let p1, p2 be Element of BoolPair;
  func p1 (+) p2 -> Element of BoolPair means
  :DefXor:
  ex b1, b2, c1, c2 being Element of BOOLEAN st
    p1 = [b1, b2] & p2 = [c1, c2] &
    it = [b1 'xor' c1, b2 'xor' c2];
  existence
  proof
    ex b1, b2 being Element of BOOLEAN st p1 = [b1, b2] by ThDecompose;
    ex c1, c2 being Element of BOOLEAN st p2 = [c1, c2] by ThDecompose;
    hence thesis;
  end;
  uniqueness;
end;

:: ============================================================================
:: Key Theorems and Techniques
:: ============================================================================

:: Theorem: Pair injectivity (ZFMISC_1:33)
::   [a, b] = [c, d] implies a = c & b = d

:: Theorem: Pair membership (ZFMISC_1:84)
::   z in [:X, Y:] implies ex x, y st x in X & y in Y & z = [x, y]

:: Theorem: Pair construction (ZFMISC_1:87)
::   x in X & y in Y implies [x, y] in [:X, Y:]

:: Boolean XOR closure (MARGREL1:def 20)
::   b1 'xor' b2 in BOOLEAN

:: ============================================================================
:: Pattern Summary
:: ============================================================================

:: STEP 1: Define decomposition theorem
::   theorem ThDecomp:
::     for p being Element of ProductType
::     ex a1, a2 being Element of ComponentType st p = [a1, a2]
::   proof by ZFMISC_1:84 with reconsider;

:: STEP 2: Define operations with "means"
::   func p1 op p2 -> ProductType means
::   ex a1, a2, b1, b2 being ... st
::     p1 = [a1, a2] & p2 = [b1, b2] &
::     it = [operation(a1, b1), operation(a2, b2)];

:: STEP 3: Prove existence by ThDecomp

:: STEP 4: Prove uniqueness by ZFMISC_1:33 (pair injectivity)

:: This pattern is IDIOMATIC in MML!
::
:: NOTE: Existence/uniqueness proofs need careful manual expansion
:: Mizar's automation doesn't always bridge from existentials to construction
:: This is a known challenge with "means" definitions
:: For production code, you may need to write out full proofs explicitly
::
:: KEY LESSON: Use accessors (Lesson 15A) when possible - they're much cleaner!