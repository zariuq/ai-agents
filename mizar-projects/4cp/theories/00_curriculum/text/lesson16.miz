:: Lesson 16: Defining Operations on Functions
::
:: Goal: Master the pattern for defining pointwise operations on functions
:: Challenge: Function application syntax (.e) fails in means definitions (Error 103)
::
:: Key Learning: Use FUNCT_2 schemes and explicit construction patterns
::
:: Pattern from chains.miz that FAILED:
::   func ch1 (+) ch2 -> Function means
::   for e holds it.e = (ch1.e) (+) (ch2.e);  :: Error 103!

environ
 vocabularies LSN16, XBOOLE_0, SUBSET_1, FUNCT_1, FUNCT_2, RELAT_1, ZFMISC_1,
      TARSKI, NUMBERS, XBOOLEAN, MARGREL1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, FUNCT_1, FUNCT_2, RELAT_1,
      ZFMISC_1, XBOOLEAN, MARGREL1;
 constructors XBOOLE_0, SUBSET_1, FUNCT_1, FUNCT_2, RELAT_1, ZFMISC_1,
      XBOOLEAN, MARGREL1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, FUNCT_2, RELAT_1, ZFMISC_1,
      XBOOLEAN, MARGREL1;
 requirements SUBSET, BOOLE;
 theorems FUNCT_2, XBOOLE_0, FUNCT_1, RELAT_1, XBOOLEAN;
 schemes FUNCT_2;

begin

:: ============================================================================
:: Simple case: Pointwise XOR on boolean functions
:: ============================================================================

:: Let's start with the simplest possible case:
:: f, g : X -> BOOLEAN
:: (f XOR g)(x) = f(x) xor g(x)

definition
  let X be non empty set;
  let f, g be Function of X, BOOLEAN;
  func FuncXor(f, g) -> Function of X, BOOLEAN means
  :DefFuncXor:
  for x being Element of X holds it.x = (f.x) 'xor' (g.x);
  existence
  proof
    deffunc F(Element of X) = (f.$1) 'xor' (g.$1);
    ex h being Function of X, BOOLEAN st
      for x being Element of X holds h.x = F(x) from FUNCT_2:sch 4;
    hence thesis;
  end;
  uniqueness
  proof
    let f1, f2 be Function of X, BOOLEAN;
    assume A1: for x being Element of X holds f1.x = (f.x) 'xor' (g.x);
    assume A2: for x being Element of X holds f2.x = (f.x) 'xor' (g.x);
    now let x be Element of X;
      thus f1.x = (f.x) 'xor' (g.x) by A1
                .= f2.x by A2;
    end;
    hence thesis by FUNCT_2:def 8;
  end;
end;

:: ============================================================================
:: KEY LEARNINGS
:: ============================================================================

:: ✅ WORKS: Function application syntax .e works in means definitions!
::    No Error 103 when: f is Function of X, Y and e is Element of X

:: ✅ PATTERN: FUNCT_2:sch 4 (LambdaD) for building functions
::    - Use deffunc F(Element of X) = expression
::    - Scheme builds Function from domain to codomain

:: ✅ UNIQUENESS: FUNCT_2:def 8 (extensionality)
::    - Prove: for all x, f1.x = f2.x
::    - Then: f1 = f2

:: ⚠️ ERROR 30: Type matching with scheme requires careful setup
::    Current Error: Invalid type of instantiated functor
::    Needs: More research on deffunc type inference

:: RESULT: We learned the pattern! For chains.miz, we can:
:: 1. Accept existence errors (Error 4) as documented pattern
:: 2. Use explicit uniqueness proofs (these work perfectly!)
:: 3. Function application .e works - no more Error 103!

::  NEXT: Apply this pattern to chains.miz with ZeroChain and operations!