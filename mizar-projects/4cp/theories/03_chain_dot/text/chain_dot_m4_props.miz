:: M4 Steps 2-4: Chain algebra properties
:: Symmetry, zero properties, and bilinearity

environ
  vocabularies
    CHAINDOT, XBOOLE_0, SUBSET_1, ZFMISC_1, XBOOLEAN, MARGREL1,
    GLIB_000, GLIB_001, GLIB_002, TARSKI, FUNCT_1, FUNCT_2,
    NUMBERS, NAT_1, CARD_1, FINSET_1, XTUPLE_0;
  notations
    TARSKI, XBOOLE_0, SUBSET_1, ZFMISC_1, XBOOLEAN, MARGREL1,
    GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2,
    NUMBERS, NAT_1, CARD_1, FINSET_1, XTUPLE_0;
  constructors
    SUBSET_1, ZFMISC_1, XBOOLEAN, MARGREL1,
    GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2,
    NAT_1, CARD_1, FINSET_1, XTUPLE_0;
  registrations
    XBOOLEAN, MARGREL1,
    GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2,
    NAT_1, CARD_1, FINSET_1, XTUPLE_0;
  requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
  theorems XBOOLE_0, XBOOLE_1, ZFMISC_1, MARGREL1, FUNCT_2,
    CARD_1, CARD_2, NAT_D, XTUPLE_0;

begin

reserve G for _Graph;
reserve x, y, z for Chain of G;

:: ============================================================================
:: M4 Step 2: Symmetry
:: ============================================================================

theorem Th_chainDot_symm:
  chainDot(x, y) = chainDot(y, x)
proof
  :: Intersections commute, cardinalities are same, parity depends only on value
  support_fst(x) /\ support_fst(y) = support_fst(y) /\ support_fst(x) by XBOOLE_1:16;
  then card(support_fst(x) /\ support_fst(y)) = card(support_fst(y) /\ support_fst(x));

  support_snd(x) /\ support_snd(y) = support_snd(y) /\ support_snd(x) by XBOOLE_1:16;
  then card(support_snd(x) /\ support_snd(y)) = card(support_snd(y) /\ support_snd(x));

  hence thesis;
end;

:: ============================================================================
:: M4 Step 3: Zero properties
:: ============================================================================

theorem Th_support_fst_zero:
  support_fst(zero_chain(G)) = {}
proof
  :: Every edge maps to zero_color = [FALSE, FALSE]
  :: So no edge has first coordinate = TRUE
  set S = support_fst(zero_chain(G));
  for e being object holds not e in S
  proof
    let e be object;
    assume e in S;
    then consider b1, b2 being Element of BOOLEAN such that
    A1: e in the_Edges_of G & (zero_chain(G).e) = [b1, b2] & b1 = TRUE;
    (zero_chain(G).e) = zero_color by A1, FUNCT_2:63;
    then [b1, b2] = [FALSE, FALSE] by A1;
    then b1 = FALSE by XTUPLE_0:1;
    hence contradiction by A1;
  end;
  hence thesis by XBOOLE_0:def 1;
end;

theorem Th_support_snd_zero:
  support_snd(zero_chain(G)) = {}
proof
  set S = support_snd(zero_chain(G));
  for e being object holds not e in S
  proof
    let e be object;
    assume e in S;
    then consider b1, b2 being Element of BOOLEAN such that
    A1: e in the_Edges_of G & (zero_chain(G).e) = [b1, b2] & b2 = TRUE;
    (zero_chain(G).e) = zero_color by A1, FUNCT_2:63;
    then [b1, b2] = [FALSE, FALSE] by A1;
    then b2 = FALSE by XTUPLE_0:1;
    hence contradiction by A1;
  end;
  hence thesis by XBOOLE_0:def 1;
end;

theorem Th_chainDot_zero_right:
  chainDot(x, zero_chain(G)) = FALSE
proof
  support_fst(zero_chain(G)) = {} by Th_support_fst_zero;
  then support_fst(x) /\ support_fst(zero_chain(G)) = {} by XBOOLE_1:3;
  then A1: card(support_fst(x) /\ support_fst(zero_chain(G))) = 0 by CARD_1:27;

  support_snd(zero_chain(G)) = {} by Th_support_snd_zero;
  then support_snd(x) /\ support_snd(zero_chain(G)) = {} by XBOOLE_1:3;
  then A2: card(support_snd(x) /\ support_snd(zero_chain(G))) = 0 by CARD_1:27;

  consider n being Nat such that
  A3: n = card(support_fst(x) /\ support_fst(zero_chain(G)))
        + card(support_snd(x) /\ support_snd(zero_chain(G))) &
      chainDot(x, zero_chain(G)) = nat_parity(n);

  n = 0 + 0 by A1, A2, A3;
  then nat_parity(n) = FALSE;

  hence thesis by A3;
end;

theorem Th_chainDot_zero_left:
  chainDot(zero_chain(G), y) = FALSE
by Th_chainDot_symm, Th_chainDot_zero_right;

:: ============================================================================
:: M4 Step 4a: Helper lemmas for bilinearity
:: ============================================================================

:: Intersection distributes over symmetric difference
theorem Th_Int_SymDiff_Distrib:
  for A, B, C being set holds A /\ (B \+\ C) = (A /\ B) \+\ (A /\ C)
proof
  let A, B, C be set;
  thus A /\ (B \+\ C) c= (A /\ B) \+\ (A /\ C)
  proof
    let x be object;
    assume x in A /\ (B \+\ C);
    then x in A & x in (B \+\ C) by XBOOLE_0:def 4;
    then x in A & ((x in B & not x in C) or (x in C & not x in B))
      by XBOOLE_0:def 3;
    then (x in A & x in B & not x in C) or (x in A & x in C & not x in B);
    then (x in A /\ B & not x in A /\ C) or (x in A /\ C & not x in A /\ B)
      by XBOOLE_0:def 4;
    hence x in (A /\ B) \+\ (A /\ C) by XBOOLE_0:def 3;
  end;
  thus (A /\ B) \+\ (A /\ C) c= A /\ (B \+\ C)
  proof
    let x be object;
    assume x in (A /\ B) \+\ (A /\ C);
    then (x in A /\ B & not x in A /\ C) or (x in A /\ C & not x in A /\ B)
      by XBOOLE_0:def 3;
    then (x in A & x in B & not x in C) or (x in A & x in C & not x in B)
      by XBOOLE_0:def 4;
    then x in A & ((x in B & not x in C) or (x in C & not x in B));
    then x in A & x in (B \+\ C) by XBOOLE_0:def 3;
    hence x in A /\ (B \+\ C) by XBOOLE_0:def 4;
  end;
end;

:: nat_parity of sum (from parity_helpers)
theorem Th_nat_parity_add:
  for m, n being Nat holds
  nat_parity(m + n) = (nat_parity m) 'xor' (nat_parity n)
proof
  :: Import from parity_helpers.miz
  let m, n be Nat;
  per cases;
  suppose m mod 2 = 1 & n mod 2 = 1;
    then (m + n) mod 2 = 0 by NAT_D:66;
    then nat_parity(m + n) = FALSE;
    nat_parity m = TRUE & nat_parity n = TRUE by NAT_D:66;
    hence thesis by MARGREL1:68;
  end;
  suppose m mod 2 = 1 & n mod 2 = 0;
    then (m + n) mod 2 = 1 by NAT_D:66;
    then nat_parity(m + n) = TRUE;
    nat_parity m = TRUE & nat_parity n = FALSE by NAT_D:66;
    hence thesis by MARGREL1:67;
  end;
  suppose m mod 2 = 0 & n mod 2 = 1;
    then (m + n) mod 2 = 1 by NAT_D:66;
    then nat_parity(m + n) = TRUE;
    nat_parity m = FALSE & nat_parity n = TRUE by NAT_D:66;
    hence thesis by MARGREL1:67;
  end;
  suppose m mod 2 = 0 & n mod 2 = 0;
    then (m + n) mod 2 = 0 by NAT_D:66;
    then nat_parity(m + n) = FALSE;
    nat_parity m = FALSE & nat_parity n = FALSE by NAT_D:66;
    hence thesis by MARGREL1:68;
  end;
end;

:: Δ-parity (from parity_helpers)
theorem Th_nat_parity_symdiff:
  for A, B being finite set holds
  nat_parity(card(A \+\ B)) = (nat_parity(card A)) 'xor' (nat_parity(card B))
proof
  let A, B be finite set;
  set a = card(A \ B);
  set b = card(B \ A);
  set i = card(A /\ B);

  A1: card(A \+\ B) = a + b by CARD_2:40;
  A2: card A = a + i & card B = b + i by CARD_2:44;

  thus nat_parity(card(A \+\ B))
     = nat_parity(a + b) by A1
    .= (nat_parity a) 'xor' (nat_parity b) by Th_nat_parity_add
    .= (nat_parity(a + i)) 'xor' (nat_parity(b + i)) by Th_nat_parity_add
    .= (nat_parity(card A)) 'xor' (nat_parity(card B)) by A2;
end;

:: ============================================================================
:: M4 Step 4b: Bilinearity
:: ============================================================================

theorem Th_chainDot_bilinear_right:
  chainDot(x, y (+) z) = (chainDot(x,y)) 'xor' (chainDot(x,z))
proof
  set A1 = support_fst x, B1 = support_fst y, C1 = support_fst z;
  set A2 = support_snd x, B2 = support_snd y, C2 = support_snd z;

  :: By support-Δ lemmas
  A1: support_fst(y (+) z) = B1 \+\ C1;  :: from M4_support
  A2: support_snd(y (+) z) = B2 \+\ C2;  :: from M4_support

  :: Intersection distribution
  A3: A1 /\ support_fst(y (+) z) = (A1 /\ B1) \+\ (A1 /\ C1)
    by A1, Th_Int_SymDiff_Distrib;
  A4: A2 /\ support_snd(y (+) z) = (A2 /\ B2) \+\ (A2 /\ C2)
    by A2, Th_Int_SymDiff_Distrib;

  :: Unfold chainDot definition and apply Δ-parity
  consider n1 being Nat such that
  A5: n1 = card(A1 /\ support_fst(y (+) z))
          + card(A2 /\ support_snd(y (+) z)) &
      chainDot(x, y (+) z) = nat_parity(n1);

  :: Apply nat_parity_add to split the sum
  A6: nat_parity(n1)
    = (nat_parity(card(A1 /\ support_fst(y (+) z))))
      'xor' (nat_parity(card(A2 /\ support_snd(y (+) z))))
    by A5, Th_nat_parity_add;

  :: Apply Δ-parity on each coordinate
  A7: nat_parity(card(A1 /\ support_fst(y (+) z)))
    = (nat_parity(card(A1 /\ B1))) 'xor' (nat_parity(card(A1 /\ C1)))
    by A3, Th_nat_parity_symdiff;

  A8: nat_parity(card(A2 /\ support_snd(y (+) z)))
    = (nat_parity(card(A2 /\ B2))) 'xor' (nat_parity(card(A2 /\ C2)))
    by A4, Th_nat_parity_symdiff;

  :: Regroup XORs
  thus chainDot(x, y (+) z)
    = ((nat_parity(card(A1 /\ B1))) 'xor' (nat_parity(card(A1 /\ C1))))
      'xor' ((nat_parity(card(A2 /\ B2))) 'xor' (nat_parity(card(A2 /\ C2))))
      by A5, A6, A7, A8
    .= ((nat_parity(card(A1 /\ B1))) 'xor' (nat_parity(card(A2 /\ B2))))
       'xor' ((nat_parity(card(A1 /\ C1))) 'xor' (nat_parity(card(A2 /\ C2))))
      :: XOR associativity/commutativity
    .= (chainDot(x, y)) 'xor' (chainDot(x, z))
      by Th_nat_parity_add;
end;

theorem Th_chainDot_bilinear_left:
  chainDot(x (+) y, z) = (chainDot(x,z)) 'xor' (chainDot(y,z))
proof
  chainDot(x (+) y, z) = chainDot(z, x (+) y) by Th_chainDot_symm;
  then chainDot(x (+) y, z) = (chainDot(z,x)) 'xor' (chainDot(z,y))
    by Th_chainDot_bilinear_right;
  then chainDot(x (+) y, z) = (chainDot(x,z)) 'xor' (chainDot(y,z))
    by Th_chainDot_symm;
  hence thesis;
end;
