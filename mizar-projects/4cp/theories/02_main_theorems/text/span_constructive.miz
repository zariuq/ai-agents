::  Constructive Face Boundary Span (clean skeleton)
::  Minimal, compile-ready infrastructure for GF(2)^2 chains and support.

environ

  vocabularies XBOOLE_0, SUBSET_1, TARSKI, NUMBERS,
    MARGREL1, XBOOLEAN, ZFMISC_1, MCART_1, FUNCOP_1,
    FINSET_1, CARD_1, NAT_1, FUNCT_1, FUNCT_2, RELAT_1,
    GLIB_000, GLIB_002, SETFAM_1, ORDINAL1;

  notations XBOOLE_0, SUBSET_1, TARSKI, NUMBERS,
    MARGREL1, XBOOLEAN, ZFMISC_1, MCART_1, FUNCOP_1,
    FINSET_1, CARD_1, NAT_1, FUNCT_1, FUNCT_2, RELAT_1,
    GLIB_000, GLIB_002, SETFAM_1, ORDINAL1;

  constructors MARGREL1, ZFMISC_1, MCART_1, FUNCOP_1,
    FINSET_1, CARD_1, NAT_1, ORDINAL1, FUNCT_2,
    GLIB_000, GLIB_002;

  registrations XBOOLE_0, SUBSET_1, XBOOLEAN, MARGREL1, RELSET_1,
    FINSET_1, FUNCT_1, FUNCT_2, NAT_1, ORDINAL1,
    GLIB_000, GLIB_002;

  requirements BOOLE, SUBSET, NUMERALS;

  definitions TARSKI, XBOOLE_0, FUNCT_1;

  theorems TARSKI, XBOOLE_0, XBOOLE_1, SUBSET_1,
    FUNCT_1, FUNCT_2, FUNCOP_1, RELAT_1,
    MARGREL1, MCART_1, CARD_1, FINSET_1, NAT_1, ORDINAL1, ZFMISC_1,
    GLIB_000, GLIB_002;

  schemes FUNCT_2;

begin

:: Subset-Family mode
definition
  let X be set;
  mode Subset-Family of X is Subset of bool X;
end;

:: Base: GF(2)^2 colors and chains
definition
  func zero_color -> Element of [: BOOLEAN, BOOLEAN :] equals [FALSE, FALSE];
::>       *140,142,203
  correctness by ZFMISC_1:87;
end;

definition
  let G be _Graph;
  mode Chain of G is Function of the_Edges_of G, [: BOOLEAN, BOOLEAN :];
::>        *303
  correctness;
end;

definition
  let G be _Graph;
  func zero_chain(G) -> Chain of G equals (the_Edges_of G) --> zero_color;
::>       *140,142,203
  correctness
  proof
    set E = the_Edges_of G;
    set f = E --> zero_color;
::>                  *140,203
    dom f = E & rng f = { zero_color } by FUNCOP_1:8;
::>                          *140,152,203
    then rng f c= [: BOOLEAN, BOOLEAN :]
::>    *178
    proof
      let y be object;
      assume y in rng f;
      then y = zero_color by TARSKI:def 1;
::>               *140,203
      thus y in [: BOOLEAN, BOOLEAN :] by ZFMISC_1:87;
::>                                     *4
    end;
    hence f is Function of E, [: BOOLEAN, BOOLEAN :] by FUNCT_2:def 1;
::>                                                                 *190
  end;
end;

:: XOR on colors
definition
  let c1, c2 be Element of [: BOOLEAN, BOOLEAN :];
  func c1 (+) c2 -> Element of [: BOOLEAN, BOOLEAN :] equals
::>      *302
    [c1`1 'xor' c2`1, c1`2 'xor' c2`2];
  correctness
  proof
    c1`1 'xor' c2`1 in BOOLEAN & c1`2 'xor' c2`2 in BOOLEAN by MARGREL1:def 20;
::>    *166                         *166
    then [c1`1 'xor' c2`1, c1`2 'xor' c2`2] in [: BOOLEAN, BOOLEAN :]
::>          *166             *166
      by ZFMISC_1:87;
    hence thesis;
  end;
end;

:: XOR on chains (pointwise)
definition
  let G be _Graph;
  let c1, c2 be Chain of G;
::>                    *306
  func c1 (+) c2 -> Chain of G means
::>      *302
  :Def_chain_add:
  for e being Element of the_Edges_of G holds
    it . e = (c1 . e) (+) (c2 . e);
  correctness
  proof
    existence
::>         *391
    proof
::>     *396
      deffunc F(Element of the_Edges_of G) = (c1 . $1) (+) (c2 . $1);
::>                                                   *330
      consider f being Function of the_Edges_of G, [: BOOLEAN, BOOLEAN :] such that
::>                                                                      *403 *200
      A1: for e being Element of the_Edges_of G holds f . e = F(e)
        from FUNCT_2:sch 4;
      take f;
      thus thesis by A1;
::>                   *144
    end;
    uniqueness
::>          *391
    proof
::>     *396
      let f1, f2 be Chain of G;
::>                        *306
      assume A1: for e being Element of the_Edges_of G holds
        f1 . e = (c1 . e) (+) (c2 . e);
::>                      *330
      assume A2: for e being Element of the_Edges_of G holds
        f2 . e = (c1 . e) (+) (c2 . e);
::>                      *330
      for e being Element of the_Edges_of G holds f1 . e = f2 . e
      proof
        let e be Element of the_Edges_of G;
        f1 . e = (c1 . e) (+) (c2 . e) by A1;
::>                       *395
        hence f1 . e = f2 . e by A2;
      end;
      hence f1 = f2 by FUNCT_2:63;
::>                             *190
    end;
  end;
end;

:: Support projections (first/second coordinate)
definition
  let G be _Graph;
  let y be Chain of G;
::>               *306
  func support_fst(y) -> Subset of the_Edges_of G equals
::>          *140,142,203
    { e where e is Element of the_Edges_of G : (y . e)`1 <> FALSE };
  correctness
  proof
    set S = { e where e is Element of the_Edges_of G : (y . e)`1 <> FALSE };
::>                                                            *165
    S c= the_Edges_of G
    proof
      let x be object;
      assume x in S;
      then ex e being Element of the_Edges_of G st x = e & (y . e)`1 <> FALSE;
::>                                                                *165
      thus thesis;
    end;
    hence thesis;
  end;
end;

definition
  let G be _Graph;
  let y be Chain of G;
::>               *306
  func support_snd(y) -> Subset of the_Edges_of G equals
::>          *140,142,203
  { e where e is Element of the_Edges_of G : (y . e)`2 <> FALSE };
  correctness
  proof
    set S = { e where e is Element of the_Edges_of G : (y . e)`2 <> FALSE };
::>                                                            *165
    S c= the_Edges_of G
    proof
      let x be object;
      assume x in S;
      then ex e being Element of the_Edges_of G st x = e & (y . e)`2 <> FALSE;
::>                                                                *165
      thus thesis;
    end;
    hence thesis;
  end;
end;

:: Key theorems (admitted for now)
theorem Th_support_fst_characterization:
::>       *203
  for G being _Graph, c being Chain of G, e being Element of the_Edges_of G
  holds (e in support_fst(c) iff (c . e)`1 <> FALSE)
proof
  let G be _Graph, c be Chain of G, e be Element of the_Edges_of G;
::>                            *306
  thus e in support_fst(c) implies (c . e)`1 <> FALSE
::>    *140       *140,203
  proof
::>   *396
    assume e in support_fst(c);
::>        *140       *140,203
    then e in { f where f is Element of the_Edges_of G : (c . f)`1 <> FALSE };
::>      *140                                                    *165
    then ex f being Element of the_Edges_of G st e = f & (c . f)`1 <> FALSE;
::>                                              *140            *165
    hence (c . e)`1 <> FALSE;
::>            *140,165
  end;
  assume (c . e)`1 <> FALSE;
::>           *140,165
  then e in { f where f is Element of the_Edges_of G : (c . f)`1 <> FALSE };
::>    *140                                                    *165
  hence e in support_fst(c);
::>     *140       *140,203
end;

theorem Th_support_snd_characterization:
::>       *203
  for G being _Graph, c being Chain of G, e being Element of the_Edges_of G
  holds (e in support_snd(c) iff (c . e)`2 <> FALSE)
proof
  let G be _Graph, c be Chain of G, e be Element of the_Edges_of G;
::>                            *306
  thus e in support_snd(c) implies (c . e)`2 <> FALSE
::>    *140       *140,203
  proof
::>   *396
    assume e in support_snd(c);
::>        *140       *140,203
    then e in { f where f is Element of the_Edges_of G : (c . f)`2 <> FALSE };
::>      *140                                                    *165
    then ex f being Element of the_Edges_of G st e = f & (c . f)`2 <> FALSE;
::>                                              *140            *165
    hence (c . e)`2 <> FALSE;
::>            *140,165
  end;
  assume (c . e)`2 <> FALSE;
::>           *140,165
  then e in { f where f is Element of the_Edges_of G : (c . f)`2 <> FALSE };
::>    *140                                                    *165
  hence e in support_snd(c);
::>     *140       *140,203
end;

theorem Th_chain_eq_by_support:
::>       *203
  for G being _Graph, c1, c2 being Chain of G
  st support_fst(c1) = support_fst(c2)
   & support_snd(c1) = support_snd(c2)
  holds c1 = c2
proof
  let G be _Graph, c1, c2 be Chain of G;
::>                                 *306
  assume A1: support_fst(c1) = support_fst(c2);
::>                 *203
  assume A2: support_snd(c1) = support_snd(c2);
::>                 *203
  for e being Element of the_Edges_of G holds c1 . e = c2 . e
  proof
    let e be Element of the_Edges_of G;
    A3: (c1 . e)`1 = (c2 . e)`1
::>              *165         *165
    proof
      per cases;
      suppose (c1 . e)`1 <> FALSE;
::>                    *165
        then e in support_fst(c1) by Th_support_fst_characterization;
::>                     *140,203
        then e in support_fst(c2) by A1;
::>                     *140,203
        then (c2 . e)`1 <> FALSE by Th_support_fst_characterization;
::>                   *165            *203
        hence thesis;
      end;
      suppose (c1 . e)`1 = FALSE;
::>                    *165
        then not e in support_fst(c1) by Th_support_fst_characterization;
::>                         *140,203
        then not e in support_fst(c2) by A1;
::>                         *140,203
        then (c2 . e)`1 = FALSE by Th_support_fst_characterization;
::>                   *165           *203
        hence thesis;
      end;
    end;
    A4: (c1 . e)`2 = (c2 . e)`2
::>              *165         *165
    proof
      per cases;
      suppose (c1 . e)`2 <> FALSE;
::>                    *165
        then e in support_snd(c1) by Th_support_snd_characterization;
::>                     *140,203
        then e in support_snd(c2) by A2;
::>                     *140,203
        then (c2 . e)`2 <> FALSE by Th_support_snd_characterization;
::>                   *165            *203
        hence thesis;
      end;
      suppose (c1 . e)`2 = FALSE;
::>                    *165
        then not e in support_snd(c1) by Th_support_snd_characterization;
::>                         *140,203
        then not e in support_snd(c2) by A2;
::>                         *140,203
        then (c2 . e)`2 = FALSE by Th_support_snd_characterization;
::>                   *165           *203
        hence thesis;
      end;
    end;
    thus c1 . e = [(c1 . e)`1, (c1 . e)`2] by MCART_1:21
::>                         *165        *165
              .= [(c2 . e)`1, (c2 . e)`2] by A3, A4
::>                        *165        *165
              .= c2 . e by MCART_1:21;
  end;
  hence c1 = c2 by FUNCT_2:63;
::>                         *190
end;

end;
::>,216
::>
::> 4: This inference is not accepted
::> 140: Unknown variable
::> 142: Unknown locus
::> 144: Unknown label
::> 152: Unknown functor format
::> 165: Unknown functor format
::> 166: Unknown functor format
::> 178: Link assumes a straightforward justification
::> 190: Inaccessible theorem
::> 200: Too long source line
::> 203: Unknown token, maybe an illegal character used in an identifier
::> 216: Unexpected "end"
::> 302: Functor symbol expected
::> 303: Mode symbol expected
::> 306: Attribute symbol expected
::> 330: Unexpected end of an item (perhaps ";" missing)
::> 391: Incorrect beginning of a text item
::> 395: Justification expected
::> 396: Formula expected
::> 403: "such" expected
