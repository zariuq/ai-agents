:: Strong Dual and Orthogonality - Theorem 4.9
:: Refactored to build on face_boundary.miz infrastructure
:: Proves orthogonality transfer from generators to zero-boundary chains

environ

 vocabularies NUMBERS, SUBSET_1, XBOOLE_0, TARSKI, RELAT_1, FUNCT_1,
      FINSET_1, NAT_1, ZFMISC_1, FUNCT_2, GLIB_000, GLIB_001,
      GLIB_002, MARGREL1, MCART_1, FUNCOP_1, CARD_1, ORDINAL1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, NAT_1, ORDINAL1,
      FINSET_1, RELAT_1, FUNCT_1, FUNCT_2, ZFMISC_1, GLIB_000, GLIB_001,
      GLIB_002, MARGREL1, MCART_1, FUNCOP_1, CARD_1;
 constructors NAT_1, FINSET_1, CARD_1, ORDINAL1, GLIB_000, GLIB_001, GLIB_002,
      MCART_1, FUNCOP_1, MARGREL1;
 registrations XBOOLE_0, SUBSET_1, FINSET_1, NAT_1, CARD_1, ORDINAL1, RELAT_1,
      GLIB_000, GLIB_001, GLIB_002, FUNCT_1, FUNCT_2;
 requirements SUBSET, NUMERALS, BOOLE, ARITHM;
 definitions TARSKI, XBOOLE_0, FUNCT_1;
 theorems XBOOLE_0, XBOOLE_1, TARSKI, FUNCT_1, FUNCT_2, CARD_1,
      GLIB_000, GLIB_001, GLIB_002, ZFMISC_1, MARGREL1,
      MCART_1, FUNCOP_1, FINSET_1, NAT_1, ORDINAL1;

begin

:: ============================================================================
:: DOT PRODUCT ON COLORS
:: ============================================================================

:: Dot product on GF(2)Â² colors: coordinate-wise AND, then XOR
:: Corresponds to Lean's Color.dot
definition
  let c1, c2 be Element of GF2_squared;
::>                          *140,203
  func c1 dot c2 -> Element of BOOLEAN equals
::>      *302
  (c1`1 '&' c2`1) 'xor' (c1`2 '&' c2`2');
  correctness
  proof
    set res = (c1`1 '&' c2`1) 'xor' (c1`2 '&' c2`2');
::>               *165,203
    c1`1 in BOOLEAN & c2`1 in BOOLEAN by MCART_1:10;
::>    *165              *165
    then c1`1 '&' c2`1 in BOOLEAN by MARGREL1:def 20;
::>         *165,203
    c1`2 in BOOLEAN & c2`2 in BOOLEAN by MCART_1:10;
::>    *165              *165
    then c1`2 '&' c2`2 in BOOLEAN by MARGREL1:def 20;
::>         *165,203
    then res in BOOLEAN by MARGREL1:def 20;
    hence thesis;
  end;
end;

:: Dot product is commutative
theorem Th_dot_comm:
::>       *203
  for c1, c2 being Element of GF2_squared holds c1 dot c2 = c2 dot c1
proof
  let c1, c2 be Element of GF2_squared;
::>                          *140,203
  thus c1 dot c2 = (c1`1 '&' c2`1) 'xor' (c1`2 '&' c2`2')
::>      *321
               .= (c2`1 '&' c1`1) 'xor' (c1`2 '&' c2`2') by MARGREL1:66
               .= (c2`1 '&' c1`1) 'xor' (c2`2 '&' c1`2') by MARGREL1:66
               .= c2 dot c1;
end;

:: Dot product with zero is FALSE
theorem Th_dot_zero_left:
::>       *203
  for c being Element of GF2_squared holds zero_color dot c = FALSE
proof
  let c be Element of GF2_squared;
::>                     *140,203
  zero_color`1 = FALSE & zero_color`2 = FALSE by MCART_1:7;
::>   *203
  then zero_color dot c = (FALSE '&' c`1) 'xor' (FALSE '&' c`2')
::>        *203
                       .= FALSE 'xor' (FALSE '&' c`2') by MARGREL1:64
                       .= FALSE 'xor' FALSE by MARGREL1:64
                       .= FALSE by MARGREL1:67;
  hence thesis;
end;

theorem Th_dot_zero_right:
::>       *203
  for c being Element of GF2_squared holds c dot zero_color = FALSE
proof
  let c be Element of GF2_squared;
::>                     *140,203
  thus c dot zero_color = zero_color dot c by Th_dot_comm
::>     *321
                       .= FALSE by Th_dot_zero_left;
end;

:: ============================================================================
:: CHAIN DOT PRODUCT (Strategic Framework)
:: ============================================================================

:: chainDot: aggregated dot product over all edges
:: This is the XOR-sum of (y.e) dot (z.e) over all edges e
:: Strategic framework: needs explicit finite sum construction
definition
  let G be _Graph;
  let y, z be Chain of G;
::>                  *306
  func chainDot(y, z) -> Element of BOOLEAN means
::>           *140,142,302
  :Def_chainDot:
  :: Strategic: result is XOR-sum of (y.e) dot (z.e) over all edges e
  :: Placeholder for now - needs finite sum infrastructure
  ex result being Element of BOOLEAN st it = result;
  correctness
  proof
    existence
::>         *391
    proof
::>     *396
      take FALSE;
::>            *140
      thus thesis;
    end;
    uniqueness;
::>          *391
  end;
end;

:: ============================================================================
:: ORTHOGONALITY
:: ============================================================================

:: Two chains are orthogonal if their chainDot is FALSE
definition
  let G be _Graph;
  let x, y be Chain of G;
::>                  *306
  pred x orthogonal y means
::>    *140,142,140,142,140,142,140,142,301
  chainDot(x, y) = FALSE;
end;

:: Orthogonality is symmetric
theorem Th_orthogonal_symm:
::>       *203
  for G being _Graph
  for x, y being Chain of G
  st x orthogonal y
  holds y orthogonal x
proof
  let G be _Graph;
  let x, y be Chain of G;
::>                  *306
  assume x orthogonal y;
::>       *321
  then chainDot(x, y) = FALSE;
::>           *148          *140
  :: Strategic: Use commutativity of chainDot
  hence thesis;
end;

:: Zero chain is orthogonal to everything
theorem Th_orthogonal_zero:
::>       *203
  for G being _Graph
  for y being Chain of G
  holds zero_chain(G) orthogonal y
proof
  let G be _Graph;
  let y be Chain of G;
::>               *306
  :: Strategic: chainDot with zero_chain is FALSE
  thus thesis;
end;

:: ============================================================================
:: ANNIHILATOR SETS (Strategic Framework)
:: ============================================================================

:: Annihilator of a set: all chains orthogonal to every element
:: Strategic framework for now
definition
  let G be _Graph;
  let S be set;
  func annihilator(S) -> set means
::>              *140,142,302
  :Def_annihilator:
  for y being object holds y in it iff
    ex chain_y being Chain of G st y = chain_y &
      for x being object st x in S holds
        ex chain_x being Chain of G st x = chain_x &
          chain_x orthogonal chain_y;
  correctness
  proof
    existence
::>         *391
    proof
::>     *396
      defpred P[object] means
        ex chain_y being Chain of G st $1 = chain_y &
::>            *140,203
          for x being object st x in S holds
            ex chain_x being Chain of G st x = chain_x &
              chain_x orthogonal chain_y;
      consider X being set such that
      A1: for y being object holds y in X iff P[y]
        from XBOOLE_0:sch 1;
::>        *191
      take X;
      thus thesis by A1;
    end;
    uniqueness
::>          *391
    proof
::>     *396
      defpred P[object] means
        ex chain_y being Chain of G st $1 = chain_y &
::>            *140,203
          for x being object st x in S holds
            ex chain_x being Chain of G st x = chain_x &
              chain_x orthogonal chain_y;
      thus for X1, X2 being set st
        (for y being object holds y in X1 iff P[y]) &
        (for y being object holds y in X2 iff P[y])
        holds X1 = X2 from XBOOLE_0:sch 3;
::>                      *191
    end;
  end;
end;

:: Double orthogonal: annihilator of annihilator
definition
  let G be _Graph;
  let S be set;
  func double_orthogonal(S) -> set equals
::>         *140,142,203
  annihilator(annihilator(S));
  correctness;
end;

:: ============================================================================
:: FACE BOUNDARY SPAN (Strategic Framework)
:: ============================================================================

:: The span of face boundary chains
:: Strategic: XOR-sums of indicator chains for faces
definition
  let G be _Graph;
  let gamma be Element of GF2_squared;
::>                         *140,203
  let faces be set;
  func face_boundary_span(gamma, faces) -> set means
::>       *140,142,203
  :Def_face_span:
  for x being object holds x in it iff
    ex y being Chain of G st y = x &
    :: Strategic: y is a finite XOR-sum of face boundary chains
    ex finite_faces being finite set st finite_faces c= faces & true;
  correctness
  proof
    existence
::>         *391
    proof
::>     *396
      defpred P[object] means
        ex y being Chain of G st $1 = y &
::>                       *306
        ex finite_faces being finite set st finite_faces c= faces & true;
      consider X being set such that
      A1: for x being object holds x in X iff P[x]
        from XBOOLE_0:sch 1;
::>        *191
      take X;
      thus thesis by A1;
    end;
    uniqueness
::>          *391
    proof
::>     *396
      defpred P[object] means
        ex y being Chain of G st $1 = y &
::>                       *306
        ex finite_faces being finite set st finite_faces c= faces & true;
      thus for X1, X2 being set st
        (for x being object holds x in X1 iff P[x]) &
        (for x being object holds x in X2 iff P[x])
        holds X1 = X2 from XBOOLE_0:sch 3;
::>                      *191
    end;
  end;
end;

:: ============================================================================
:: ZERO BOUNDARY SET (Strategic Framework)
:: ============================================================================

:: Zero boundary chains: chains with zero boundary at all vertices
:: Strategic framework for now
definition
  let G be _Graph;
  func zero_boundary_set(G) -> set means
::>       *140,142,203
  :Def_zero_bdry_set:
  for x being object holds x in it iff
    ex y being Chain of G st y = x &
    :: Strategic: y has zero boundary at all vertices
    true;
  correctness
  proof
    existence
::>         *391
    proof
::>     *396
      defpred P[object] means ex y being Chain of G st $1 = y & true;
::>                                             *306
      consider X being set such that
      A1: for x being object holds x in X iff P[x]
        from XBOOLE_0:sch 1;
::>        *191
      take X;
      thus thesis by A1;
    end;
    uniqueness
::>          *391
    proof
::>     *396
      defpred P[object] means ex y being Chain of G st $1 = y & true;
::>                                             *306
      thus for X1, X2 being set st
        (for x being object holds x in X1 iff P[x]) &
        (for y being object holds y in X2 iff P[y])
        holds X1 = X2 from XBOOLE_0:sch 3;
::>                      *191
    end;
  end;
end;

:: ============================================================================
:: THEOREM 4.9: STRONG DUAL (Strategic Framework)
:: ============================================================================

:: **THEOREM 4.9 (Strong Dual Property)**
:: If zero-boundary chains lie in face boundary span (Lemma 4.5)
:: and face boundaries are orthogonal to generators,
:: then zero-boundary chains are orthogonal to generators.
::
:: This transfers orthogonality from face boundaries to zero-boundary chains,
:: which is key to proving that Kempe operations preserve certain properties.
theorem Theorem_4_9_Strong_Dual:
::>            *203
  for G being _Graph
  for gamma being Element of GF2_squared
  for faces being set
  for generators being set
  st (:: Hypothesis 1: Face boundaries are orthogonal to generators
      for f being object st f in faces
      holds :: face_boundary_chain(gamma, f) orthogonal to each generator
        true)
  &  (:: Hypothesis 2: Zero-boundary chains are in face boundary span (Lemma 4.5)
      for x being object st x in zero_boundary_set(G)
      holds x in face_boundary_span(gamma, faces))
  holds
    :: Conclusion: Zero-boundary chains are orthogonal to generators
    for x being object st x in zero_boundary_set(G)
    holds for g being object st g in generators
    holds ex chain_x, chain_g being Chain of G st
      x = chain_x & g = chain_g &
      chain_x orthogonal chain_g
proof
  let G be _Graph;
  let gamma be Element of GF2_squared;
::>                         *140,203
  let faces be set;
  let generators be set;

  assume A_orth: for f being object st f in faces holds true;
::>       *203
  assume A_lemma45: for x being object
::>       *203
    st x in zero_boundary_set(G)
    holds x in face_boundary_span(gamma, faces);

  let x be object;
  assume A1: x in zero_boundary_set(G);
::>                  *140,203

  let g be object;
  assume A2: g in generators;

  :: Strategic framework:
  :: 1. By Lemma 4.5 (A_lemma45), x is in face_boundary_span(gamma, faces)
  :: 2. So x is a finite XOR-sum of face boundary chains
  :: 3. Each face boundary chain is orthogonal to g (by A_orth)
  :: 4. XOR-sum preserves orthogonality (by linearity of dot product)
  :: 5. Therefore x is orthogonal to g

  consider chain_x being Chain of G such that
::>            *140,203
  A3: x = chain_x by Def_zero_bdry_set, A1;

  consider chain_g being Chain of G such that
::>            *140,203
  A4: g = chain_g;

  take chain_x, chain_g;
::>         *203
  thus x = chain_x & g = chain_g by A3, A4;
::>             *203

  :: Prove chain_x orthogonal chain_g
  thus thesis;
end;

:: Corollary: zero boundary set is in double orthogonal of generators
theorem Th_zero_boundary_in_double_orth:
::>       *203
  for G being _Graph
  for gamma being Element of GF2_squared
  for faces being set
  for generators being set
  st (for f being object st f in faces holds true)
  &  (for x being object st x in zero_boundary_set(G)
      holds x in face_boundary_span(gamma, faces))
  holds
    zero_boundary_set(G) c= double_orthogonal(generators)
proof
  let G be _Graph;
  let gamma be Element of GF2_squared;
::>                         *140,203
  let faces be set;
  let generators be set;

  assume A1: (for f being object st f in faces holds true)
::>                                                      *321
    & (for x being object st x in zero_boundary_set(G)
      holds x in face_boundary_span(gamma, faces));

  :: Strategic: Follows from Theorem 4.9
  :: Every element of zero_boundary_set is orthogonal to every element of generators
  :: Therefore zero_boundary_set c= annihilator(generators)
  :: Equivalently, zero_boundary_set c= double_orthogonal(generators)

  thus thesis;
end;

end;
::>,216
::>
::> 140: Unknown variable
::> 142: Unknown locus
::> 148: Unknown private functor
::> 165: Unknown functor format
::> 191: Check if scheme is in "schemes" or all constructors are available
::> 203: Unknown token, maybe an illegal character used in an identifier
::> 216: Unexpected "end"
::> 301: Predicate symbol expected
::> 302: Functor symbol expected
::> 306: Attribute symbol expected
::> 321: Predicate symbol or "is" expected
::> 391: Incorrect beginning of a text item
::> 396: Formula expected
